<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ALU结构和原理</title>
    <url>/2023/05/11/ALU/</url>
    <content><![CDATA[<h1 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h1><p>先来看看维基百科是怎么说的</p>
<blockquote>
<p><strong>算术逻辑单元</strong> （英语：Arithmetic logic unit，<a href="https://zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB" title="缩写">缩写</a>： <strong>ALU</strong> ）是一种可对<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6" title="二进制">二进制</a><a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0" title="整数">整数</a>执行<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF" title="算术">算术运算</a>或<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C" title="位操作">位运算</a>的<a href="https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF" title="组合逻辑电路">组合逻辑</a><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF" title="数字电路">数字电路</a>。ALU 与<a href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8" title="浮点运算器">浮点数运算单元</a>（FPU）不同，后者仅对<a href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8" title="浮点运算器">浮点数</a>进行操作。ALU 是许多类型的计算电路的基本部件，这些计算电路包括计算机的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8" title="中央处理器">中央处理单元</a>（CPU）、<a href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8" title="浮点运算器">浮点处理单元</a>（FPU）和<a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8" title="图形处理器">图形处理单元</a>（GPU）。单个CPU、FPU 或 GPU 可能包含多个 ALU。</p>
<p>–维基百科</p>
</blockquote>
<p>ALU就是计算机中用来进行算数逻辑运算的核心单元，我们可以用它来进行加减乘除等操作</p>
<h2 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h2><p>为了实现最基本的加法功能，我们可以使用逻辑门搭建一个半加器，在这里：<a href="https://deltamaya.top/2023/05/10/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/">逻辑门</a>，我介绍了如何用晶体管搭建逻辑门。</p>
<p>先来看看结构：<br><img src="/../image/ALU/1683766407298.png" alt="半加器"></p>
<p>我们使用异或门对A和B进行运算，但是这样无法判定进位，所以我们又加入了一个与门来判定是否进位<br>其中A和B就是要执行操作的两个bit，sum就是求和之后的低位，carry是进位。</p>
<h2 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h2><p>但是，如果我们需要进行超过1+1的运算，就需要使用全加器<br><img src="/../image/ALU/1683766572913.png" alt="全加器"><br>这里我们就可以对进位也进行运算了，A和B就是要进行运算的两个位，C是低位运算进上来的位，我们可以通过全加器对三个位进行运算，同样输出结果sum和进位carry</p>
<h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><p>万事俱备，这样我们就可以使用半加器和全加器对任意两个二进制数进行运算了，低位使用半加器，后面的每一位使用全加器即可，如图：<br><img src="/../image/ALU/1683767140631.png" alt="加法器"><br>A和B是两个8位的二级制数，后面跟的数字代表是第几位，这里我们注意到，最后一个全加器依然输出了一个carry，如果两个数的运算让这个carry是1，说明这两个数相加太大，超过了8位可以表示的范围，叫做溢出</p>
<blockquote>
<p>尽管每个进位消耗的时间很少，但是在计算机每秒数十亿次的计算中，这种消耗也是很难以接受的，所以现代处理器中一般使用<strong>超前进位加法器</strong>，结构与这里略有不同</p>
</blockquote>
<h2 id="其他运算器"><a href="#其他运算器" class="headerlink" title="其他运算器"></a>其他运算器</h2><p><img src="/../image/ALU/1683767512270.png" alt="其他运算"><br>这是ALU中可以进行的一部分其他操作，就像加法器，它们也是使用一个个逻辑门搭建出来的</p>
<h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><img src="/../image/ALU/1683767778314.png" alt="ALU"><br>可以看到，ALU在接受A和B两个输入进行运算时，还会产生3个标志位，比如overflow会在结果溢出时置为1，zero会在结果为0时置为一<br>高级ALU有更多的标志位，但这三种是最普遍的</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>计算机组成</tag>
        <tag>ALU</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU结构和原理</title>
    <url>/2023/05/10/CPU/</url>
    <content><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>首先我们来看一下什么是CPU：</p>
<blockquote>
<p><strong>中央处理器</strong> （英语：<strong>C</strong>entral <strong>P</strong>rocessing <strong>U</strong>nit，缩写： <strong>CPU</strong> ）是<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA" title="电子计算机">计算机</a>的主要设备之一，功能主要是解释计算机<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4" title="指令">指令</a>以及处理计算机<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" title="软件">软件</a>中的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE" title="数据">数据</a>。</p>
<p>–维基百科</p>
</blockquote>
<h2 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h2><p><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683714535332.png" alt="CPU结构"><br>可以看到，CPU中有若干寄存器、ALU和一个控制单元，大体介绍一下这些组件的功能：</p>
<ul>
<li>寄存器：CPU中用来暂时存储数据、处理数据的小型存储区域</li>
<li>ALU（算数逻辑单元）：用来执行算数或者逻辑操作</li>
<li>控制单元：控制各个组件的运行</li>
</ul>
<h3 id="寄存器、ALU"><a href="#寄存器、ALU" class="headerlink" title="寄存器、ALU"></a>寄存器、ALU</h3><p>关于寄存器和ALU的介绍我单独写了博客，你可以在这里查看：<a href="https://deltamaya.top/2023/05/11/ALU/">ALU</a>、<a href="https://deltamaya.top/2023/05/11/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/">寄存器</a></p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器中也有若干寄存器，其中一个叫做<strong>PC(Program Counter)程序计数器</strong>、一个叫做<strong>IR(Instruction Register)指令寄存器</strong>，PC中存储着计算机要执行的<strong>下一条指令的地址</strong>，IR中则存储着计算机<strong>要执行的指令</strong>，它们都被编码为了二进制。以及**PSW(程序状态字, Program Status Word)**用于记录条件码（ALU使用）、CPU优先级、模式（内核&#x2F;用户）、以及其他控制位。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>CPU是计算机用于执行指令的一个组件，指令就是计算机中的一个个操作，例如将一个值拷贝到一个地方、将两个值相加..</p>
<p>因为CPU无法理解自然语言，所以如果要执行指令，我们就要对指令进行编码，为了简化模型，这里我们以8位的长度举例：<br><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683712829076.png" alt="指令编码"><br>这里对四条指令进行了编码，每个指令都有自己的操作码和操作数，<br>在这里一条指令的前四位是<strong>操作码</strong>，后四位是<strong>操作数</strong><br>操作码对应CPU要执行的操作，操作数对应CPU操作的对象<br>在需要执行指令时，CPU将会根据操作码和操作数进行具体的操作。</p>
<p>不同的CPU指令级会有不同的编码，所以不同架构下的二进制文件不能混合使用，因为指令编码不同</p>
<blockquote>
<p>计算机的指令需要存储在<strong>内存RAM</strong>中，如果你对此不太了解可以看这篇博客：<a href="./%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98.md">寄存器和内存</a></p>
</blockquote>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>这里先以取数为例</p>
<p><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683715030031.png" alt="取数的执行过程"></p>
<ol>
<li><strong>取指令</strong>：开机之后PC中存储着要执行的指令的地址，PC将这个地址传给MAR，然后内存在这个地址中搜索，将地址中存储的值传给MDR，然后再传回CPU的IR中</li>
<li><strong>解码</strong>：CU控制单元对IR中的指令进行解码，得到操作码对应要执行的操作，得到操作数对应要执行操作的对象</li>
<li><strong>执行</strong>：经过分析，这条指令的内容是从一个地址中取出一个数放到某个寄存器中。那么CPU就会将这个地址传给MAR，然后将取得的数放到寄存器中。</li>
<li>指令执行结束，PC自增1，指向下一条指令</li>
</ol>
<h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>在上面描述的一个周期中，我们需要在状态之间不断切换，那怎样才能知道接下来要做什么呢？<br>答案就是：<strong>时钟</strong></p>
<p>时钟是一个电子元件，以准确的时间间隔触发电信号，<br>这个循环执行一次就叫做一个<strong>时钟周期</strong></p>
<blockquote>
<p>取指令 -&gt; 解码 -&gt; 执行<br><strong>CPU就会根据时钟信号推进上述周期的执行。</strong></p>
</blockquote>
<p>例如，如果一个CPU的频率是5.0 GHz，那么这个CPU就可以每秒操作50亿</p>
<h3 id="超频"><a href="#超频" class="headerlink" title="超频"></a>超频</h3><p><strong>超频</strong>就是通过提高时钟频率来达到<strong>提高CPU性能</strong>的目的，<br>芯片制造商一般会为CPU留一些余地，可以接受一些超频，但是长时间的超频可能会造成过热，或者会产生乱码，因为信号跟不上时钟</p>
<h3 id="降频"><a href="#降频" class="headerlink" title="降频"></a>降频</h3><p>你可能很少听说<strong>降频</strong>，但是降频是一个很好的手段来<strong>降低能耗</strong><br>当你的手机或者其他移动设备没有进行很多计算时，对CPU进行降频减慢CPU的计算速度可以减少能耗，提高续航</p>
<blockquote>
<p>现代的很多处理器都可以根据需求调整时钟频率</p>
</blockquote>
<h1 id="高级CPU设计"><a href="#高级CPU设计" class="headerlink" title="高级CPU设计"></a>高级CPU设计</h1><p>早期对CPU进行优化提速的方法主要是减少晶体管的切换时间，但是这种优化硬件的方法很快就遇到了瓶颈，所以厂商们探索出了更多的设计模式，可以大大提高CPU的运行速度</p>
<h2 id="优化电路"><a href="#优化电路" class="headerlink" title="优化电路"></a>优化电路</h2><p>早期的CPU进行除法时要调用多次减法，这样会花费很多个时钟周期，在操作很大或者很多的数的时候效率十分低下，所以厂商们研发出了直接用于除法的ALU电路，解决了这个问题，提高了运行速度</p>
<p>随着计算机的发展，CPU中也加入了更多可以快速执行原先需要很多时钟周期才能完成的指令的电路</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>很高的主频则会带来另一个问题，CPU从内存读取指令的速度一般需要几个时钟周期，远跟不上CPU执行指令的速度，这会让CPU处于等待状态，效率低下</p>
<p>所以我们在CPU中加入了<strong>Cache缓存</strong>，在读取指令时CPU可以一次性从内存<strong>读取多条指令暂存到缓存</strong>中，这是很实用的，因为计算机中大多是时候指令都是顺序执行。</p>
<p><img src="/image/CPU/1688552307227.png" alt="1688552307227"></p>
<p>现代系统一般具有三级缓存：</p>
<p>L1cache，大小为kb级，访问没有时延</p>
<p>L2cache，大小为mb级，访问有1~2个时钟周期。L2cache可以放在CPU内部（ARM），也可以多个CPU共同使用（x86）</p>
<p>在CPU执行完一条指令之后可以马上从缓存读取下一条指令而无需等待内存</p>
<p>当想要的内容在缓存中时叫做缓存命中<strong>cache hit</strong><br>不在缓存中则成为缓存未命中<strong>cache miss</strong></p>
<p>缓存也可以存储一些临时值，用于复杂计算</p>
<h3 id="脏位"><a href="#脏位" class="headerlink" title="脏位"></a>脏位</h3><p>当我们计算完一些值需要写到内存中时，我们可以将其<strong>暂存到缓存</strong>，如果后续还要接着算，这么做也会提高效率。</p>
<p>当我们把一个数据存到缓存中，我们把这个缓存中的位置标记为<strong>脏位（Dirty bit）</strong><br><strong>同步</strong>一般会发生在缓存已经写满，但还需要从内存读取数据时<br>同步时CPU会<strong>把脏位中的数据先写到RAM</strong>，然后再从RAM进行读取</p>
<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683719476635.png" alt="非流水线模式"><br>因为取指令、解码、执行分别用的CPU中不同的组件，在非流水线模式下CPU同一时刻只能用到某部分组件，效率低下</p>
<p><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683719503473.png" alt="流水线模式"><br>现在很多CPU都有单独的取指、解码、执行单元，不同单元之间可以单独执行，互不影响，如上图所示。在同一时间可以执行多个操作。</p>
<p>流水线模式下同时调动CPU中的全部组件，<a href="https://zh.wikipedia.org/wiki/%E5%90%9E%E5%90%90%E9%87%8F">吞吐量</a>*3</p>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>流水线并行执行下处理器会根据指令间的关系进行<strong>拓扑排序</strong>，得到理论上对计算结果没有影响的执行顺序</p>
<p>但是有时候这样做会带来并发问题，所以我们要注意指令间的依赖性，或者在代码中加入<strong>内存屏障</strong>在必要的时候停止流水线，防止出现错误</p>
<p>在现代处理器中往往会对流水线进行优化，当出现cache miss时，与其花费大量时间等待从内存中取出目标指令时，cpu可以选择先执行这条指令后面cache hit的指令，这叫做<strong>乱序执行</strong>，也叫做<strong>超标量CPU</strong></p>
<h3 id="预测执行"><a href="#预测执行" class="headerlink" title="预测执行"></a>预测执行</h3><p>最后，当程序出现条件控制时，原始的处理器会等待判断结果，然后再根据结果执行，效率低下</p>
<p>现代处理器中，一般采用一些算法来预测程序接下来要执行的程序，这叫做<strong>分支预测</strong></p>
<p>在判断结果出来之前就进行读取。当判断结果出来之后，如果猜测是正确的，那么此时缓存中都是正确的指令，马上就可以执行</p>
<p>如果猜测错误，那么就会<strong>清空流水线</strong>，耗费大量时间</p>
<p>但是不用担心，现代处理器猜测<strong>命中率超过90%</strong></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程也叫超线程，就是允许CPU保持两个不同的线程状态，然后再纳秒级的时间内来回切换</p>
<p>这可以让操作系统将一个CPU当作多个CPU使用，个数取决于这个CPU支持的线程数</p>
<h2 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h2><p>上面的方法都是优化一个指令流的速度<br>而多核，也就是在CPU中添加多个独立处理单元，来同时执行多个指令流</p>
<p>多核可以在一个多核芯片上放值多个单核芯片，每个单核芯片就是一个CPU</p>
<h2 id="多CPU"><a href="#多CPU" class="headerlink" title="多CPU"></a>多CPU</h2><p>同样的，一台计算机里多塞几个CPU也能提高效率</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>处理器就是在计算机中不断进行 <code>取指、解码、执行</code> 循环的部件，每进行一次循环叫做一个CPU周期。</p>
<p>每个CPU都有一套指令集，不同指令集之间不可以混淆</p>
<p>大多数CPU都有PC（程序计数器）、堆栈指针，和 PSW（程序状态字, Program Status Word）用于记录条件码（ALU使用）、CPU优先级、模式（内核&#x2F;用户）、以及其他控制位。</p>
<p>为了提高计算效率，现代CPU采用了流水线、预测执行、乱序执行、多核、多线程的方法。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序算法</title>
    <url>/2023/04/11/Sorts/</url>
    <content><![CDATA[<h1 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h1><hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>十分经典的排序算法，其思想就是依次比较相邻的几个元素，如果逆序就进行交换，如此一趟排序就可以将最大的一个数放到最后，或者将最小的一个数放到最前，就像冒泡一样，因此得名冒泡排序。<br>算法实现（优化版）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;sz;++i)&#123;</span><br><span class="line"><span class="comment">//ok用来记录是否已经有序，为真就提前结束算法</span></span><br><span class="line">		<span class="type">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sz-i;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[j<span class="number">-1</span>]&gt;v[j])&#123;<span class="comment">//有等号时没有稳定性</span></span><br><span class="line">				<span class="built_in">swap</span>(v[j<span class="number">-1</span>],v[j]);</span><br><span class="line">				ok=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ok)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>稳定性：稳定<br><em>当for循环的判断为&gt;&#x3D;或者&lt;&#x3D;时不具备稳定性，因为交换了等值数</em></p>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序就像打牌时插牌一样，拿到一个数之后向已经有序的数组插入，只需要不断向前交换直到前面没有数或者前一个数不大于这个数为止。<br>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;v.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="type">int</span> tmp=i;</span><br><span class="line"><span class="comment">//当有等号时不具备稳定性</span></span><br><span class="line">		<span class="keyword">while</span>(tmp<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;v[tmp<span class="number">-1</span>]&gt;v[tmp])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[tmp<span class="number">-1</span>],v[tmp]);</span><br><span class="line">			--tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(N^2)<br><em>需要注意，插入排序在排序基本有序的数据时有独特的优势，最好可以达到O(N),在排序完全逆序数时是最坏情况，为O(N^2)</em><br>空间复杂度：O(1)<br>稳定性：稳定<br><em>与冒泡排序同理，若交换等值数不具备稳定性</em></p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>十分朴素的一种排序算法，通过对数据进行一次完整遍历来选择出最值，然后将其放到最左或者最右。<br>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> left=<span class="number">0</span>,right=v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="type">int</span> mini=left,maxi=left;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=left;j&lt;=right;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[j]&gt;v[maxi])maxi=j;</span><br><span class="line">			<span class="keyword">if</span>(v[j]&lt;v[mini])mini=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[left],v[mini]);</span><br><span class="line"><span class="comment">//当left与maxi重合时，交换left和mini会使maxi指向最小mini指向最大，所以叫更新mexi的位置</span></span><br><span class="line">		<span class="keyword">if</span>(left==maxi)&#123;</span><br><span class="line">			maxi=mini;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[right],v[maxi]);</span><br><span class="line">		++left;--right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>稳定性：<strong>不稳定</strong><br><em>这里需要格外注意，很多人认为选择排序选最值的方法是稳定的，但是当面对特殊情况下会不稳定，例如：【2，2，1，1】，当选择出最小值时与最左边的值交换，这样就破坏了数据2内的稳定性</em></p>
<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序的核心思想与插入排序一致，但是希尔排序会先对数组进行预排序，使之基本有序，当进行最后一趟排序（也就是插入排序时）会变得很快。<br>预排序时，先每个几个元素进行预插入排序，这样可以使大数很快的跳到后部，小数很快的跳的前部，提高了效率。<br>算法实现；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> gap=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span>(gap&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		gap=gap/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">//也可以选择/2，只要最后一趟是1即可</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;v.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			<span class="type">int</span> tmp=i;</span><br><span class="line">			<span class="keyword">while</span>(tmp-gap&gt;=<span class="number">0</span>&amp;&amp;v[tmp-gap]&gt;v[tmp])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[tmp-gap],v[tmp]);</span><br><span class="line">				tmp-=gap;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：希尔排序的时间复杂度很难进行分析，目前一般认为是O(N^(1.3))左右<br>空间复杂度：O(1)<br>稳定性：不稳定<br><em>虽然插入排序是稳定的，但是希尔排序因为进行了分组，使得同一个数在一组里面可能跳到前面也可能跳到后面，破坏了稳定性</em></p>
<hr>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序利用了二叉堆这种数据结构的性质，它可以轻松的选出一组数里权最大的元素，我们只需要建堆，然后不断将堆顶元素放到数据末端即可。<br>算法实现（详见：<a href="https://deltamaya.top/2023/03/28/%E5%A0%86md/">堆</a>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//向下调整建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">		<span class="type">int</span> father=i,child=(i*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//将堆顶元素与末尾元素交换，然后将堆顶元素向下调整即可</span></span><br><span class="line">	<span class="keyword">while</span>(sz--)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line">		<span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(NlogN)<br>空间复杂度：O(1)<br>稳定性：不稳定</p>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想就是每一趟选定一个数作为key，在一趟排序中将所有比key小的数放到k前面，比k大的数放到k后面，经过一趟这样的排序key就能在最终应该在的位置。<br>选key可以使用随机k法和三数取中法，可以使快排的最坏情况更难出现。<br>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归+双指针法+三数取中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span> (&#123;<span class="number">0</span>,v.<span class="built_in">size</span>()<span class="number">-1</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> left=q.<span class="built_in">front</span>().first,right=q.<span class="built_in">front</span>().second;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> k= <span class="built_in">find_mid</span> (left,right,(left+right)/<span class="number">2</span>,v);</span><br><span class="line">		<span class="built_in">swap</span>(v[k],v[left]);</span><br><span class="line">		k=left;</span><br><span class="line">		<span class="type">int</span> less,cur;</span><br><span class="line">		less=cur=left;</span><br><span class="line">		++cur;</span><br><span class="line">		<span class="keyword">while</span>(cur&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[cur]&lt;v[k]&amp;&amp;++less!=cur)&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[less],v[cur]);</span><br><span class="line">			&#125;</span><br><span class="line">			++cur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[less],v[k]);</span><br><span class="line">		<span class="keyword">if</span>(left&lt;less<span class="number">-1</span>)q.<span class="built_in">push</span> (&#123;left,less<span class="number">-1</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(right&gt;less+<span class="number">1</span>)q.<span class="built_in">push</span> (&#123;less+<span class="number">1</span>,right&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是当数据存在多个重复值时会退化到O(N^2)，我们使用三路划分进行解决</span></span><br><span class="line"><span class="comment">//递归+随机取k+三路划分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickRec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=begin,r=end,cur=l+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//**************leetcode上使用三数取中会TLE，建议使用随机取k***************</span></span><br><span class="line">	<span class="built_in">swap</span>(v[begin+<span class="built_in">rand</span>()%(end-begin+<span class="number">1</span>)],v[l]);</span><br><span class="line">	<span class="type">int</span> target=v[l];</span><br><span class="line">	<span class="keyword">while</span>(cur&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[cur]&lt;target)&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[cur],v[l]);</span><br><span class="line">			++cur;++l;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[cur]==target)&#123;</span><br><span class="line">			++cur;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[r],v[cur]);</span><br><span class="line">			--r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(begin&lt;l<span class="number">-1</span>)<span class="built_in">QuickRec</span>(v,begin,l<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(cur&lt;end)<span class="built_in">QuickRec</span>(v,cur,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********注：当左右边界缩小到一定值时可以使用直接插入排序进行优化，gap一般取10左右******************</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(NlogN)<br>空间复杂度：O(logN)<br><em>需要进行递归或者使用数据记录开始和结束位点</em><br>稳定性：不稳定</p>
<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序与快速排序同样采用分治法对数据进行排序，将两组有序的数组进行归并，变成一个有序的更大的数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortRec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v,<span class="type">int</span> begin,<span class="type">int</span> end,vector&lt;<span class="type">int</span>&gt;&amp;tmp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(begin&gt;=end)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">MergeSortRec</span> (v,begin,mid,tmp);</span><br><span class="line">	<span class="built_in">MergeSortRec</span> (v,mid+<span class="number">1</span>,end,tmp);</span><br><span class="line">	<span class="type">int</span> begin1=begin,end1=mid;</span><br><span class="line">	<span class="type">int</span> begin2=mid+<span class="number">1</span>,end2=end;</span><br><span class="line">	<span class="type">int</span> m=begin;</span><br><span class="line">	<span class="keyword">while</span>(begin1&lt;=end1&amp;&amp;begin2&lt;=end2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[begin1]&lt;v[begin2])&#123;</span><br><span class="line">			tmp[m++]=v[begin1++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp[m++]=v[begin2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(begin1&lt;=end1)&#123;</span><br><span class="line">		tmp[m++]=v[begin1++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(begin2&lt;=end2)&#123;</span><br><span class="line">		tmp[m++]=v[begin2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;=end;++i)&#123;</span><br><span class="line">		v[i]=tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> tmp=v;</span><br><span class="line">	<span class="type">int</span> gap=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( gap &lt; v.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>( i &lt; v.<span class="built_in">size</span>() / gap / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> left_begin = i * <span class="number">2</span> * gap, left_end = left_begin + gap - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> right_begin = left_end + <span class="number">1</span>, right_end = right_begin + gap - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> m = left_begin;</span><br><span class="line">			<span class="comment">//进行边界划分</span></span><br><span class="line">			<span class="comment">//如果rb越界，直接跳出循环，只有一组的不需要归并和拷贝</span></span><br><span class="line">			<span class="keyword">if</span>( right_begin &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>( right_end &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">				right_end= v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//用来打印边界debug</span></span><br><span class="line">			<span class="comment">//printf(&quot;[%d,%d][%d,%d] &quot;,left_begin,left_end,right_begin,right_end);</span></span><br><span class="line">			<span class="keyword">while</span> ( left_begin &lt;= left_end &amp;&amp; right_begin &lt;= right_end ) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( v[ left_begin ] &lt; v[ right_begin ] ) &#123;</span><br><span class="line">					tmp[ m++ ] = v[ left_begin++ ];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tmp[ m++ ] = v[ right_begin++ ];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> ( left_begin &lt;= left_end ) &#123;</span><br><span class="line">				tmp[ m++ ] = v[ left_begin++ ];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> ( right_begin &lt;= right_end ) &#123;</span><br><span class="line">				tmp[ m++ ] = v[ right_begin++ ];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t=i*<span class="number">2</span>*gap;t&lt;=right_end;++t)&#123;</span><br><span class="line">				v[t]=tmp[t];</span><br><span class="line">			&#125;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		gap*=<span class="number">2</span>;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(NlogN)<br>空间复杂度：O(N)<br>稳定性：稳定</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../img/sort_summary.png" alt="总结"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2023/03/30/binary_tree/</url>
    <content><![CDATA[<h1 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h1><p><img src="/../img/binary_tree_show.jpg" alt="树"></p>
<blockquote>
<p><strong>结点的度</strong>：一个结点含有的子树的个数称为该结点的度； 如上图：A的为6</p>
<p><strong>叶结点或终端结点</strong>：度为0的结点称为叶结点； 如上图：B、C、H、I…等结点为叶结点</p>
<p><strong>非终端结点或分支结点</strong>：度不为0的结点；  如上图：D、E、F、G…等结点为分支结点</p>
<p><strong>双亲结点或父结点</strong>：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点</p>
<p><strong>孩子结点或子结点</strong>：一个结点含有的子树的根结点称为该结点的子结点；  如上图：B是A的孩子结点</p>
<p><strong>兄弟结点</strong>：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点</p>
<p><strong>树的度</strong>：一棵树中，最大的结点的度称为树的度； 如上图：树的度为6</p>
<p><strong>结点的层次</strong>：从根开始定义起，根为第1层，根的子结点为第2层，以此类推； </p>
<p><strong>树的高度或深度</strong>：树中结点的最大层次；  如上图：树的高度为4</p>
<p><strong>堂兄弟结点</strong>：双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点</p>
<p><strong>结点的祖先</strong>：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先</p>
<p><strong>子孙</strong>：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙</p>
<p><strong>森林</strong>：由m（m&gt;0）棵互不相交的树的集合称为森林；  </p>
</blockquote>
<h1 id="二叉树的结构"><a href="#二叉树的结构" class="headerlink" title="二叉树的结构"></a>二叉树的结构</h1><p>一棵二叉树又三个部分组成：</p>
<ul>
<li>根节点</li>
<li>左子树</li>
<li>右子树</li>
</ul>
<p>我们将树的结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode*left;</span><br><span class="line">	TreeNode*right;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>),<span class="built_in">height</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">	<span class="built_in">TreeNode</span>(): <span class="built_in">TreeNode</span> (<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此当我们需要遍历(Traversal)一棵二叉树时，有四种遍历方法：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>遍历顺序：<strong>根节点-&gt;左子树-&gt;右子树</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">Process</span>(root);</span><br><span class="line">	<span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>遍历顺序：<strong>左子树-&gt;根节点-&gt;右子树</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">Process</span>(root);</span><br><span class="line">	<span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>遍历顺序：<strong>左子树-&gt;右子树-&gt;根节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">latOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">latOrder</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">latOrder</span>(root-&gt;right);</span><br><span class="line">	<span class="built_in">Process</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>遍历顺序：<strong>逐层</strong><br>层序遍历相对比较复杂，我们需要用一个队列来记录<strong>所有同层的节点</strong>然后依次遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">layerOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">	queue&lt;TreeNode*&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		TreeNode *f = q.<span class="built_in">front</span> ();</span><br><span class="line">		<span class="keyword">if</span> ( f-&gt;left )q.<span class="built_in">push</span> (f-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> ( f-&gt;right )q.<span class="built_in">push</span> (f-&gt;right);</span><br><span class="line">		<span class="built_in">Process</span> (f);</span><br><span class="line">		q.<span class="built_in">pop</span> ();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>我们不难发现，所谓的 X序遍历 就是根节点在顺序中的位置</em></p>
<p>二叉树本身就是递归的定义的，所以我们可以得知，二叉树算法中最重要的一点就是递归。</p>
<h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是$2^k -1$ ，则它就是满二叉树。</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</p>
<h2 id="一般二叉树"><a href="#一般二叉树" class="headerlink" title="一般二叉树"></a>一般二叉树</h2><p>对于深度为n的一棵二叉树，节点个数在n至2^n-1之间。<br>同理，对于节点个数为n的二叉树，深度在log(n+1)至n之间。</p>
<blockquote>
<ol>
<li>若规定根结点的层数为1，则一棵非空二叉树的<strong>第i层上最多有2^(i-1)</strong> 个结点.</li>
<li>若规定根结点的层数为1，则<strong>深度为h的二叉树的最大结点数是2^h-1</strong>.</li>
<li>对任何一棵二叉树, <strong>如果度为0其叶结点个数为 n_0, 度为2的分支结点个数为 n_2,则有n_0＝n_2＋1</strong></li>
<li>若规定根结点的层数为1，具有<strong>n个结点的满二叉树的深度</strong>，<strong>h&#x3D;log_2(n+1)</strong>.  (ps：log_2(n+1)是log以2为底，n+1为对数)</li>
<li>对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对于序号为i的结点有：<ol>
<li><strong>若i&gt;0，i位置结点的双亲序号：(i-1)&#x2F;2</strong>；i&#x3D;0，i为根结点编号，无双亲结点</li>
<li><strong>若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;&#x3D;n否则无左孩子</strong></li>
<li><strong>若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;&#x3D;n否则无右孩子</strong></li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言基础</title>
    <url>/2023/07/02/assmbly_basics/</url>
    <content><![CDATA[<h1 id="汇编语言基础"><a href="#汇编语言基础" class="headerlink" title="汇编语言基础"></a>汇编语言基础</h1><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>在汇编语言中有三种操作数：</p>
<ol>
<li>立即数</li>
<li>寄存器</li>
<li>内存引用</li>
</ol>
<p>立即数使用 <code>$</code>符号开头，表示一个整数<br>寄存器使用 <code>%</code>符号开头，表示一个寄存器中存放的值<br>内存引用一般使用 <code>Imm(ra,rb,s)</code>表示，其中ra，rb是寄存器的名字，表示内存中（ra+s*rb）+Imm位置存放的值<br>其中ra叫做基址寄存器，rb叫做变址寄存器，s叫做比例因子，Imm叫做立即数偏移<br>注意，这里s必须是1，2，4，8。并且基址寄存器和变址寄存器必须都是64位寄存器</p>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p>数据传送指令一般长 <code>MOV S,D</code>这个样子<br>它的作用是将S中的值放入到D中<br>注意，S和D不能同时为内存地址，如果需要就需要使用两条MOV指令，先将内存地址的值放入某个临时寄存器，然后将寄存器的值放到另一个内存地址</p>
<h2 id="MOV指令的分类"><a href="#MOV指令的分类" class="headerlink" title="MOV指令的分类"></a>MOV指令的分类</h2><p>MOV指令根据操作数的大小可以分为movb，movw，movl，movq四条指令<br>b表示的是字节，w表示的是字，表示两个字节，l表示双字，四个字节，q表示四字，八个字节<br>此外mov还支持扩展传送：<code>mov+ s/z+ b/w/l/q + b/w/l/q src dest</code><br>表示的是将第一个bwlq大小的数据扩展为第二个bwlq大小，然后传送进入dest处，其中z表示零扩展，s表示符号扩展<br>特殊的，movabsq表示绝对四字</p>
<h2 id="算数逻辑操作"><a href="#算数逻辑操作" class="headerlink" title="算数逻辑操作"></a>算数逻辑操作</h2><p>大致有以下几种类型<br><code>INC D</code>表示D+&#x3D;1<br><code>DEC D</code>表示D-&#x3D;1<br><code>NEG D</code>表示D&#x3D;-D<br><code>ADD S,D</code>表示D+&#x3D;S<br><code>SAL k,D</code>表示D&lt;&lt;&#x3D;k<br><code>SHL k,D</code>同上<br><code>SAR k,D</code>算数右移D&gt;&gt;&#x3D;k<br><code>SHR k,D</code>逻辑右移D&gt;&gt;&#x3D;k<br>和 <code>lea S,D</code>，叫做加载有效地址load effective address<br>注意，lea与mov指令操作数是一样的，但是不会进行解引用操作，直接将左边的值放入右侧<br>lea也有时会被用于进行简单的计算</p>
<h2 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h2><p>CPU中还维护着一组单个位的条件码寄存器，<br>最常用的条件码有：CF进位标志，ZF零标志，SF符号标志，OF溢出标志</p>
<p>我们可以使用 <code>set</code>指令设置状态位</p>
<p>也可以通过 <code>test A,B</code> or <code>cmp A,B</code>设置状态位，其中test指令的含义就是根据A&amp;B得到的值来设置状态位，cmp指令是根据B-A得到的值来设置状态位</p>
<h2 id="JMP指令"><a href="#JMP指令" class="headerlink" title="JMP指令"></a>JMP指令</h2><p>通过上面所说的状态位，我们可以根据不同的境况来使用jmp指令，从而达成条件控制的效果</p>
<p>下面是几个例子</p>
<p><code>jmp dest</code>无条件跳转到dest处</p>
<p><code>je dest</code>如果零标志被设置则跳转至dest</p>
<p><code>jns dest</code>如果符号标志没有被设置则跳转至dest</p>
<p><code>jae dest</code>&#x3D;<code>jnb dest</code>（用于无符号数比较）&gt;&#x3D; 则跳转</p>
<p><code>jge dest</code>&#x3D;<code>jnl dest</code>（用于有符号数标胶）&gt;&#x3D; 则跳转</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>汇编语言中使用 <code>call func</code>指令来调用函数</p>
<p>使用call指令之前，需要先将参数放入对应寄存器，函数的前六个参数分别使用 <code>%rdi %rsi %rdx %rcx %r8 %r9</code>这六个寄存器</p>
<p>然后超出的部分放入调用函数的栈帧的栈顶，并且自顶向下分别是第7，第8……个参数</p>
<p>函数的返回值放在 <code>%rax</code>中</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算的奇技淫巧</title>
    <url>/2023/06/15/bit_optricks/</url>
    <content><![CDATA[<h1 id="计算加法"><a href="#计算加法" class="headerlink" title="计算加法"></a>计算加法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==<span class="string">&quot;0&quot;</span>)<span class="keyword">return</span> b;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="string">&quot;0&quot;</span>)<span class="keyword">return</span> a;</span><br><span class="line">	string ret;</span><br><span class="line">	<span class="type">bool</span> carry=<span class="literal">false</span>;</span><br><span class="line">	std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	std::<span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">min</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());++i)&#123;</span><br><span class="line">		ret.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>+((a[i]==<span class="string">&#x27;1&#x27;</span>)^(b[i]==<span class="string">&#x27;1&#x27;</span>)^carry));</span><br><span class="line">		carry=((a[i]==<span class="string">&#x27;1&#x27;</span>)+(b[i]==<span class="string">&#x27;1&#x27;</span>)+<span class="built_in">int</span>(carry))&gt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>())&#123;</span><br><span class="line">		ret.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>+((a[i]==<span class="string">&#x27;1&#x27;</span>)^carry));</span><br><span class="line">		carry=((a[i]==<span class="string">&#x27;1&#x27;</span>)+<span class="built_in">int</span>(carry))&gt;<span class="number">1</span>;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;b.<span class="built_in">size</span>())&#123;</span><br><span class="line">		ret.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>+((b[i]==<span class="string">&#x27;1&#x27;</span>)^carry));</span><br><span class="line">		carry=((b[i]==<span class="string">&#x27;1&#x27;</span>)+<span class="built_in">int</span>(carry))&gt;<span class="number">1</span>;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(carry)ret.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">	std::<span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计算乘法"><a href="#计算乘法" class="headerlink" title="计算乘法"></a>计算乘法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(b&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			temp+=a;</span><br><span class="line">			b-=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			a&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">			b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a+temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计算除法"><a href="#计算除法" class="headerlink" title="计算除法"></a>计算除法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(b != <span class="number">0</span>); <span class="comment">// 断言除数不能为0 否则下面while会死循环</span></span><br><span class="line">	<span class="type">bool</span> flag = !((a&gt;&gt;<span class="number">31</span>)^(b&gt;&gt;<span class="number">31</span>)); <span class="comment">// flag为true表示最终答案为正</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把a b先转为无符号整数 负数位移会计算错</span></span><br><span class="line">	<span class="type">unsigned</span> _a = a &lt; <span class="number">0</span> ? ~a + <span class="number">1U</span> : a; <span class="comment">// 负数是补码形式 取反+1得到相反数</span></span><br><span class="line">	<span class="type">unsigned</span> _b = b &lt; <span class="number">0</span> ? ~b + <span class="number">1U</span> : b;</span><br><span class="line">	<span class="type">unsigned</span> ret = <span class="number">0U</span>;</span><br><span class="line">	<span class="type">int</span> pos = <span class="number">31</span>; <span class="comment">// b不能为0 a右移32位必定为0 必定小于b 所以pos初始为31</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该循环执行位运算乘法的逆运算</span></span><br><span class="line">	<span class="keyword">while</span> (_a &gt;= _b) &#123;</span><br><span class="line">		<span class="keyword">while</span> ((_a &gt;&gt; pos) &lt; _b) pos--;</span><br><span class="line">		_a -= (_b &lt;&lt; pos);</span><br><span class="line">		ret |= (<span class="number">1U</span> &lt;&lt; pos);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否溢出</span></span><br><span class="line">	<span class="keyword">if</span> (ret &gt; INT_MAX) &#123;</span><br><span class="line">		<span class="keyword">return</span> flag ? INT_MAX : INT_MIN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> flag ? (<span class="type">int</span>)ret : -(<span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="统计整数中1的位数"><a href="#统计整数中1的位数" class="headerlink" title="统计整数中1的位数"></a>统计整数中1的位数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(a)&#123;</span><br><span class="line">		++cnt;</span><br><span class="line">		a=a&amp;(a<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="统计前n个数中1的位数"><a href="#统计前n个数中1的位数" class="headerlink" title="统计前n个数中1的位数"></a>统计前n个数中1的位数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp;&amp; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> meet=<span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(n+<span class="number">1</span>);</span><br><span class="line">	ret[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		ret[i]=ret[i-meet]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(++cnt==meet)&#123;</span><br><span class="line">			cnt=<span class="number">0</span>;</span><br><span class="line">			meet*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">move</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2023/04/23/KMP_algorithm/</url>
    <content><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP算法是一种字符串查找算法，他可以返回字串在原始字符串中第一次出现的位置。<br>时间复杂度是 O(M+N) 空间复杂度O(M)</p>
<p>KMP算法核心逻辑：<strong>当字符不匹配时，从与前一个字符对应的最长相同前后缀的长度之后继续进行搜索</strong></p>
<p>前缀：一定包含首字符但不包含尾字符的连续字串<br>后缀：一定包含尾字符但不包含首字符的连续子串</p>
<p>通俗来讲，当你在某一个字符匹配不上的时候，此时前面所有字符组成的字符串中存在某一个前缀和后缀是相同的（ps：这里都是从前到后读，而<strong>不是</strong>前缀从前往后而，后缀从后往前），所以当你从这个后缀的首字符开始匹配时，一定可以完成这个前缀的匹配，所以我们就不用费力再做一遍了，于是我们直接跳转到这个前缀的后一个字符继续匹配。</p>
<p>例如：text&#x3D;”ABAABABCA”  target&#x3D;”ABABC”<br>target最长相同前后缀的长度数组为：00120</p>
<ol>
<li>当搜索到下标为3时，A与B不匹配，此时从与B的前一个字符A匹配的最长相同前后缀的后面继续搜索，与A匹配的最长前后缀为A，长度为1，所以我们保持text中的指针不动，target中的指针移动到下标为1的位置，我们可以保证下标1之前的元素一定就在text指针的前面，因为我们用target的前缀替代了后缀</li>
<li>同理，B与A然不匹配，此时target指针跳转到0位置，继续搜索</li>
<li>然后不断向前匹配，知道target指针结束或者text指针结束</li>
</ol>
<hr>
<p>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">const</span> string&amp; str,<span class="type">const</span> string&amp; target)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;next;</span><br><span class="line">	<span class="comment">//next数组用于存放每个位置对应的最长相同前后缀的长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;target.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(j+len&lt;=i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(target[j]==target[j+len])&#123;</span><br><span class="line">				++cnt;</span><br><span class="line">				++j;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				++len;</span><br><span class="line">				cnt=<span class="number">0</span>;</span><br><span class="line">				j=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		next.<span class="built_in">push_back</span> (cnt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,f=<span class="number">0</span>,begin=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;str.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i]!=target[f])&#123;</span><br><span class="line">			<span class="keyword">if</span>(f)f=next[f<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				++i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(str[i]==target[f])&#123;</span><br><span class="line">			<span class="keyword">if</span>(f==target.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> i-f;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==str.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			++i;++f;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f)f=next[f<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>搜索</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>布尔逻辑与逻辑门</title>
    <url>/2023/05/10/bool_logic_and_doors/</url>
    <content><![CDATA[<h1 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h1><p>布尔逻辑中存在两个状态：true和false<br>刚好对应每一个bit的两个状态：1和0<br>存在三种运算与(AND)、或(OR)、非(NOT)<br>通过这三种布尔运算，我们就可以在计算机中进行运算</p>
<h1 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h1><p>在计算机中，我们可以通过逻辑门实现这三种布尔运算逻辑：</p>
<h2 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h2><p>对于布尔运算，我们有一种很好用的电子元件叫做<strong>晶体管</strong></p>
<blockquote>
<p>晶体管一般都有三个极，其中一极兼任输入及输出端子，(B)基极不能做输出，(C)集电极不能做输入之外，其余两个极组成输入及输出对。 晶体管之所以有如此多用途在于其信号放大能力，当微细信号加于其中的一对极时便能控制在另一对极较大的信号，这特性叫<a href="https://zh.wikipedia.org/wiki/%E5%A2%9E%E7%9B%8A" title="增益">增益</a>。</p>
<p>–维基百科</p>
</blockquote>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683685214282.png" alt="晶体管实体"><br><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683685326237.png" alt="晶体管电路图"><br>我们可以将顶部的<strong>基极B作为输入</strong>，将底部的<strong>集电极C作为输出</strong>，那么当我们B输入高电平的时候C也会得到高电平，输入低电平的时候C也会得到低电平，这样我们就得到了一个真值表：true-&gt;true  false-&gt;false</p>
<p><em>这看上去没什么意思，因为最基本的原理我们都懂。</em></p>
<h2 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h2><p>但是在这个晶体管的基础上，我们稍加修改就可以实现<strong>NOT非门</strong>：</p>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683685734975.png" alt="非门"><br>依然将B作为输入，但是我们将输出改为上图的模式，C级接地</p>
<p>那么当我们的B输入true的时候，上下导通，将E端的电流接地，导致输出端没有高电平，输出false<br>而当B输入false，地线不导通，直接流向输出端，此时输出false</p>
<h2 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h2><p>将两个晶体管<strong>串联</strong>，我们就得到了<strong>AND与门</strong>：</p>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683686119690.png" alt="与门"></p>
<p>当一个或者没有晶体管的B级接通时，电路无法导通<br>此时满足AND的真值表，构成与门</p>
<h2 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h2><p>由 <em>与门</em> 我们自然可以得知 <em>或门</em> 的结构，<br>将两个晶体管<strong>并联</strong>，可以得到<strong>OR或门</strong>：<br><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683686324190.png" alt="或门"></p>
<p>当两个晶体管其中的一个导通时，输出端也导通<br>此时满足OR的真值表，构成或门</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>由于这几种门在电路中出现十分频繁，所以我们可以将它们简写成如下形式：</p>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683686573047.png" alt="符号"></p>
<p>如图，我们在图纸上画出这些图形的时候，实际的晶体管和电线依然存在，但是我们将他们抽象封装成了一个符号，这可以让我们的图纸更加简介明了</p>
<h2 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h2><p>我们可以根据以上三种门搭建出另一种常见的门，<strong>XOR异或门</strong>：</p>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683686816940.png" alt="异或门"></p>
<p>下面是异或门的布尔逻辑表达式</p>
<blockquote>
<p>A  <em>xor</em>  B &#x3D; ( <em>not</em>( A <em>and</em> B )  <em>and</em>  ( A <em>or</em> B ) )</p>
</blockquote>
<p>也就是说，<em>A异或B</em>  就是 <em>A或B里有一个true 并且 A和B不能都为true</em></p>
<p>我们也可以通过离散数学中的一个公式帮助理解：</p>
<blockquote>
<p>A  <em>xor</em>  B &#x3D; ( A  <em>and</em>  <em>not</em>B )  <em>or</em>  ( <em>not</em>A <em>and</em> B)</p>
</blockquote>
<p>当A与B相同时，or左右两侧值相同两侧一定都为false，得到的值也为false</p>
<p>当A与B不同时，or左右两侧的值至少有一侧为true，输出true</p>
<h1 id="抽象-1"><a href="#抽象-1" class="headerlink" title="抽象"></a>抽象</h1><p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683687474009.png" alt="基本符号"><br>上面是一些逻辑门的抽象符号</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" title="计算机科学">计算机科学</a>中， <strong>抽象化</strong> （英语：Abstraction）是将资料与程序，以它的语义来呈现出它的外观，但是隐藏起它的实现细节。抽象化是用来减少程序的复杂度，使得程序员可以专注在处理少数重要的部分。一个电脑系统可以分割成几个<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B1%A4" title="抽象层">抽象层</a>（Abstraction layer），使得程序员可以将它们分开处理。</p>
<p>–维基百科</p>
</blockquote>
<p>在这里我们了解到了<strong>抽象</strong>的含义，我们将隐藏复杂组件中具体的实现细节，将精力放到自己要做的事情上。<br>例如：一个程序员不需要了解自己写的程序需要几个晶体管几个逻辑门，也不需要了解电子在电路中是怎么移动的，但是他依然可以写出可以运行的程序，这就是抽象的意义。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>位运算</tag>
        <tag>布尔逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉堆</title>
    <url>/2023/03/28/binary_heap/</url>
    <content><![CDATA[<h1 id="二叉堆的结构"><a href="#二叉堆的结构" class="headerlink" title="二叉堆的结构"></a>二叉堆的结构</h1><p>二叉堆又称<strong>优先队列</strong>，其本质上就是一颗<strong>完全二叉树</strong>，并使用数组表示。<br>堆又分为<strong>大根堆与小根堆</strong>，<br>大根堆就是对于每个节点，它的值比左孩子的值和右孩子的值都大<br>小根堆即对于每个节点，它的值比左孩子和右孩子的值都小</p>
<p>以大根堆为例，堆的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;heap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> sz;</span><br><span class="line">	<span class="built_in">Heap</span>():<span class="built_in">heap</span>(),<span class="built_in">sz</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="堆的性质（大根堆）"><a href="#堆的性质（大根堆）" class="headerlink" title="堆的性质（大根堆）"></a>堆的性质（大根堆）</h1><p>大根堆的性质就是对于每个节点，它的值比左孩子的值和右孩子的值都大。<br>为了维护这个性质，在每次插入和删除元素之后我们都要调整堆的结构。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入调整方式如图所示：<br><img src="/../img/heapPush.png" alt="堆插入"></p>
<p>当子节点还存在父节点时，若子节点大于父节点，则调换两者位置，然后更新父节点与子节点的位置，知道条件不成立或者子节点没有父节点。<br>具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	heap.<span class="built_in">push_back</span> (x);</span><br><span class="line"><span class="comment">//每个节点的父节点都可以由(n-1)/2求得</span></span><br><span class="line"><span class="comment">//向上调整</span></span><br><span class="line">	<span class="type">int</span> child=sz,father=(sz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&amp;&amp;heap[child]&gt;heap[father])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(heap[child],heap[father]);</span><br><span class="line">		child=father;</span><br><span class="line">		father=(father<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	++sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除时，我们需要注意需要把最后一个元素与堆顶元素进行交换，然后将堆顶元素向下调整。<br><img src="/../img/heapPop.png" alt="堆弹出"><br>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=heap[<span class="number">0</span>];</span><br><span class="line">	--sz;</span><br><span class="line">	<span class="built_in">swap</span>(heap[<span class="number">0</span>],heap[sz]);</span><br><span class="line"><span class="comment">//向下调整</span></span><br><span class="line">	<span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="comment">//选出子节点的最大值</span></span><br><span class="line">		<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;heap[child+<span class="number">1</span>]&gt;heap[child]) &#123;</span><br><span class="line">			++child;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(heap[child]&gt;heap[father])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(heap[child],heap[father]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		father=child;</span><br><span class="line">		child=child*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><p>堆的性质可以帮助我们选出一组数据中<strong>权最大的那个元素</strong>（在这个例子中是数值最大的元素），因此我们可以使用其性质进行排序。</p>
<h2 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="comment">//向上调整建堆</span></span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;++i)&#123;</span><br><span class="line">		<span class="type">int</span> child=i,father=(child<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&amp;&amp;v[child]&gt;v[father])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			child=father;</span><br><span class="line">			father=(father<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始排序</span></span><br><span class="line">	<span class="keyword">while</span>(--sz)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line">		<span class="type">int</span> child=<span class="number">1</span>,father=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最容易想到的方法是对一个数组向上调整建堆，就像逐个插入一样，但是这样做的时间复杂度是<strong>O(nlogn)<strong>，其实我们有更快的方法，那就是</strong>向下调整建堆</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="comment">//向下调整建堆</span></span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> tmp=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;tmp&gt;<span class="number">0</span>;--tmp)&#123;</span><br><span class="line">		<span class="type">int</span> father=tmp,child=father*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始排序</span></span><br><span class="line">	<span class="keyword">while</span>(--sz)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line">		<span class="type">int</span> child=<span class="number">1</span>,father=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们可以从数学角度证明，向下调整建堆的时间复杂度是O(n)，优于向上建堆。<br>数学证明如下：<br><img src="/../img/upAdjustMath.png" alt="向上调整建堆"></p>
<p><img src="/../img/downAdjustMath.png" alt="向下调整建堆"></p>
<p>此外，我们要注意，建堆并不是排序的过程，因此升序需要建大堆，降序要建小堆</p>
<h2 id="TopK："><a href="#TopK：" class="headerlink" title="TopK："></a>TopK：</h2><p>由于二叉堆的性质，我们可以不断的选出一组数据中权最大数，这就是TopK问题：<br>例如：<br>我们可以通过小根堆选出100000个数中最大10个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topK</span><span class="params">(ifstream&amp; fin,<span class="type">const</span> <span class="type">int</span>&amp; K)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(K);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;++i)&#123;</span><br><span class="line">		fin&gt;&gt;ret[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向下调整建堆(小根堆）</span></span><br><span class="line">	<span class="type">int</span> sz=K;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> tmp=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;tmp&gt;<span class="number">0</span>;--tmp)&#123;</span><br><span class="line">		<span class="type">int</span> father=tmp,child=father*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;ret[child+<span class="number">1</span>]&lt;ret[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ret[child]&lt;ret[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(ret[child],ret[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	<span class="keyword">while</span>(fin&gt;&gt;tmp)&#123;</span><br><span class="line">		<span class="comment">//比堆顶大就入堆</span></span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;ret[<span class="number">0</span>])&#123;</span><br><span class="line">			ret[<span class="number">0</span>]=tmp;</span><br><span class="line">			<span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//向下调整</span></span><br><span class="line">			<span class="keyword">while</span>(child&lt;K)&#123;</span><br><span class="line">				<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;ret[child+<span class="number">1</span>]&lt;ret[child])&#123;</span><br><span class="line">					++child;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(ret[child]&lt;ret[father])&#123;</span><br><span class="line">					<span class="built_in">swap</span>(ret[child],ret[father]);</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">				father=child;</span><br><span class="line">				child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，与堆排序不同，<strong>topK要把目标权最小的元素放在堆顶</strong>，例如这里要选出最大的，就要把目前所遇到的最小的元素放在堆顶，使用小根堆</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>并发控制</title>
    <url>/2023/05/16/concurrency_management/</url>
    <content><![CDATA[<blockquote>
<p>先导知识：<a href="https://deltamaya.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></p>
</blockquote>
<h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p><img src="/../image/concurrency_management/1688611310053.png" alt="1688611310053"></p>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p> 每个程序都是一个状态机，在运行时他会发生状态的转移，例如执行完每一条指令之后i的值从0变为了1，那么i的状态就发生了改变，同时，程序的状态也发生了改变，因此，我们只需要知道程序的初始状态和状态转移方程就能得到所有的可能性，从而判断是否会有error发生</p>
<blockquote>
<p>程序中存在程序员写出的bug，也称为fault，然后这个程序在运行时产生了不应该产生的状态，称为error，然后一个或者若干个error状态之后程序会panic或者崩溃，产生了可观测的错误，称为failure。debug的过程就是通过failure来寻找fault的过程</p>
</blockquote>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p> 当多个线程一起访问内存中的一个区域时，可能会发生一些出乎意料的情况，例如一个线程在执行i++的时候，另一个线程也在执行i++，线程A先读取i的值，计算完毕但是还没来得及写入内存中时，线程B又读取了i的值，计算然后写入了内存，导致两次i++最后只执行了一次。<br> 例如：</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p> 能够访问共享内存的程序片段叫做临界区critical section</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i )&#123;</span><br><span class="line">   		sum++;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i )&#123;</span><br><span class="line">   		sum++;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> begin=<span class="built_in">clock</span>();</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(fn1)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(fn2)</span></span>;</span><br><span class="line">	<span class="comment">//Sleep(1);</span></span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">clock</span>()-begin&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
<blockquote>
<p>0<br>100321429<br>101206072<br>297</p>
</blockquote>
<p>而且每次执行中三次sum的值都不相同，并且最后的值并不是200000000，同样验证了上面的描述，i++不是一个原子操作</p>
<p> 一个原子操作有两个关键属性，帮助你使用多个线程正确操控对象，而无需使用 mutex 锁，我们知道printf是一个原子的操作，所以当函数体换为不断调用printf时不会因为多线程而打印出错误的字符</p>
<p><img src="/../image/concurrency_management/1688611435487.png" alt="1688611435487"></p>
<h2 id="信息传递"><a href="#信息传递" class="headerlink" title="信息传递"></a>信息传递</h2><p>信息的发送和接受也隐含着同步。</p>
<p>一般最常用的信息传递方法是：无阻塞send，阻塞receive</p>
<p>还有两者都阻塞的情况，这种情况下阻塞两个进程直到完成信息的传递，也成为会合</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>两个进程之间可以直接使用对方的pid来指定进程，这种情况下就需要事先知道希望得到哪个进程的信息，这种方法在并发进程之间的合作非常有效。</p>
<p>但是也有一种情况，就是不知道信息的来源，就需要使用一个<strong>信箱</strong>作为中间数据结构（队列，发送和接受的地址都是用信箱的地址。</p>
<p>使用信箱可以实现多对多的信息传递，让多个服务进程为用户进程提供服务</p>
<h1 id="互斥-x2F-同步"><a href="#互斥-x2F-同步" class="headerlink" title="互斥&#x2F;同步"></a>互斥&#x2F;同步</h1><p><img src="/../image/concurrency_management/1688611501732.png" alt="1688611501732"></p>
<p>同步是指协调多个并发执行的线程或进程之间的操作顺序和状态。</p>
<p><img src="/../image/concurrency_management/1688612349782.png" alt="1688612349782"></p>
<p>它的目的是确保数据的一致性和正确性，避免并发访问共享资源时出现竞态条件（race condition）和其他潜在的并发问题。我们可以通过给线程上锁，让线程之间互斥，使得同一时刻有且只有一个线程能够访问某个内存</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>互斥锁主要有以下几种类型：</p>
<ol>
<li>二进制锁（Binary Lock）：也称为互斥锁（Mutex Lock），是最常见的一种互斥锁类型。它只有两个状态：锁定和非锁定。一次只能被一个线程持有，其他线程需要等待持有锁的线程释放后才能获得锁。</li>
<li>递归锁（Recursive Lock）：也称为可重入锁（Reentrant Lock），允许同一个线程多次获得锁。线程每次成功获得锁后，需要相应释放相同次数才能完全释放锁。递归锁主要用于处理嵌套调用或递归函数中的锁定。</li>
<li>公平锁（Fair Lock）：在锁被释放后，等待时间最长的线程将会最先获得锁。这种锁保证了所有线程都有公平竞争的机会，避免了某些线程一直被饿死的问题。</li>
<li>自旋锁（Spin Lock）：与互斥锁不同，自旋锁是一种忙等待锁，线程在获取锁失败时会一直尝试获取锁，而不是进入休眠状态。自旋锁适用于锁定时间很短的场景，避免线程切换带来的开销。</li>
<li>读写锁（Read-Write Lock）：也称为共享-独占锁，允许多个线程同时读取共享数据，但只允许一个线程独占写入数据。读写锁可以提高并发性，适用于读多写少的场景。</li>
</ol>
<p>这些是常见的互斥锁类型，不同类型的互斥锁适用于不同的并发场景，选择适当的锁可以提高程序的性能和可靠性。</p>
<p>我们可以通过使用锁来达成线程之间的同步，这里有一种十分容易想到的锁，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNLOCK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKED 1</span></span><br><span class="line"><span class="type">int</span> lock=UNLOCK;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i )&#123;</span><br><span class="line">		<span class="keyword">while</span>(lock==LOCKED);</span><br><span class="line">		lock=LOCKED;</span><br><span class="line">		sum++;</span><br><span class="line">		lock=UNLOCK;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i )&#123;</span><br><span class="line">		<span class="keyword">while</span>( lock == LOCKED );</span><br><span class="line">		lock = LOCKED;</span><br><span class="line">		sum++;</span><br><span class="line">		lock = UNLOCK;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> begin=<span class="built_in">clock</span>();</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(fn1)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(fn2)</span></span>;</span><br><span class="line">	<span class="comment">//Sleep(1);</span></span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">clock</span>()-begin&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种实现是不安全的，首先，当fn1检查lock时发现没有上锁，跳出循环，此时fn1还没来得及将lock置为LOCKED，fn2线程又去检查lock，发现依然没有上锁，于是两个线程就并发地访问sum，导致结果错误。</p>
<blockquote>
<p>0<br>103724764<br>104755397<br>545</p>
</blockquote>
<p>我们可以通过Peterson算法对其进行改进：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> flag1=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> flag2=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> lock=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i )&#123;</span><br><span class="line">		flag1=<span class="number">1</span>;__sync_synchronize();</span><br><span class="line">		lock=<span class="number">2</span>;__sync_synchronize();</span><br><span class="line">		<span class="keyword">while</span>(flag2&amp;&amp;lock!=<span class="number">1</span>);</span><br><span class="line">		sum++;__sync_synchronize();</span><br><span class="line">		flag1=<span class="number">0</span>;__sync_synchronize();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i )&#123;</span><br><span class="line">		flag2=<span class="number">1</span>;__sync_synchronize();</span><br><span class="line">		lock=<span class="number">1</span>;__sync_synchronize();</span><br><span class="line">		<span class="keyword">while</span>(flag1&amp;&amp;lock!=<span class="number">2</span>);</span><br><span class="line">		sum++;__sync_synchronize();</span><br><span class="line">		flag2=<span class="number">0</span>;__sync_synchronize();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> begin=<span class="built_in">clock</span>();</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(fn1)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(fn2)</span></span>;</span><br><span class="line">	<span class="comment">//Sleep(1);</span></span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">clock</span>()-begin&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>261<br>199323130<br>200000000<br>17493</p>
</blockquote>
<p>我们可以看到程序正确地输出了结果，但是运行时间明显增加了，这是因为使用while循环空转会浪费很多CPU资源，尤其是当线程数比CPU数多的时候，一个线程拿到锁之后被OS中断，其他线程只能空转，实现100%的资源浪费，效率十分低下。这本质上是一种自旋锁</p>
<blockquote>
<p>__sync_synchronize()的作用是建立一个memory barrier，防止处理器的乱序执行，使指令的执行顺序与代码逻辑一致</p>
</blockquote>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">std::atomic_flag lock = ATOMIC_FLAG_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>(std::memory_order_acquire))</span><br><span class="line">			;  <span class="comment">// 自旋等待锁释放</span></span><br><span class="line">		<span class="comment">// 进入临界区</span></span><br><span class="line">		sum++;</span><br><span class="line">		<span class="comment">// 离开临界区</span></span><br><span class="line">		lock.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>(std::memory_order_acquire))</span><br><span class="line">			;  <span class="comment">// 自旋等待锁释放</span></span><br><span class="line">		<span class="comment">// 进入临界区</span></span><br><span class="line">		sum++;</span><br><span class="line">		<span class="comment">// 离开临界区</span></span><br><span class="line">		lock.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> begin=<span class="built_in">clock</span>();</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(fn1)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(fn2)</span></span>;</span><br><span class="line">	<span class="comment">//Sleep(1);</span></span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">clock</span>()-begin&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了自旋锁来达到互斥，自旋锁并不适用于长时间的临界区或在高并发的情况下，因为自旋等待期间会持续占用CPU资源</p>
<blockquote>
<p>0<br>194418646<br>200000000<br>10042</p>
</blockquote>
<p>并且，程序的scalability很低，随着线程数量的增加，程序的执行时间会增加而不是减少。<br>但是自旋锁也是有意义的，它适用于短临界区，可以避免上下文的切换，因此在操作系统内核中的并发数据结构广泛存在，避免了线程切换的开销</p>
<h2 id="互斥锁（二进制锁）"><a href="#互斥锁（二进制锁）" class="headerlink" title="互斥锁（二进制锁）"></a>互斥锁（二进制锁）</h2><p>因为自旋锁的效率问题，可以使用互斥锁替代</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i) &#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 获取互斥锁</span></span><br><span class="line">		<span class="comment">// 进入临界区</span></span><br><span class="line">		sum++;</span><br><span class="line">		<span class="comment">// 离开临界区，互斥锁会在lock_guard析构时自动释放</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i) &#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 获取互斥锁</span></span><br><span class="line">		<span class="comment">// 进入临界区</span></span><br><span class="line">		sum++;</span><br><span class="line">		<span class="comment">// 离开临界区，互斥锁会在lock_guard析构时自动释放</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0<br>199594799<br>200000000<br>7955</p>
</blockquote>
<p>我们使用了std::mutex作为互斥锁来保护临界区，使用std::lock_guard作为互斥锁的 RAII（Resource Acquisition Is Initialization）封装，确保在离开临界区时自动释放锁。</p>
<p>注意，互斥锁的使用方式与自旋锁不同，互斥锁在获取失败时会将线程置于休眠状态，等待锁的释放，而不会忙等待。这样可以避免空转消耗 CPU 资源，提高效率。</p>
<p>阻塞</p>
<p>我们可以通过以下技术达成线程之间的同步</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>互斥锁确保了对共享资源的互斥访问和同步，而条件变量则用于线程的阻塞和唤醒，以便在满足特定条件时进行适当的操作。<br>条件变量通常与互斥锁结合使用，以确保在等待和唤醒操作中的线程安全性。条件变量本身不提供同步功能，它依赖于互斥锁来保护共享数据的一致性。</p>
<p>我们可以使用互斥锁+条件变量实现 生产者-消费者模型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c version</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cv;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mtx;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">pleft</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mtx);</span><br><span class="line">		<span class="keyword">while</span>(cnt&gt;=n)&#123;</span><br><span class="line">			pthread_cond_wait(&amp;cv,&amp;mtx);</span><br><span class="line">		&#125;</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">		pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">		pthread_cond_broadcast(&amp;cv);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">pright</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mtx);</span><br><span class="line">		<span class="keyword">while</span>(cnt&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">			pthread_cond_wait(&amp;cv,&amp;mtx);</span><br><span class="line">		&#125;</span><br><span class="line">		--cnt;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">		pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">		pthread_cond_broadcast(&amp;cv);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	pthread_cond_init(&amp;cv,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_mutex_init(&amp;mtx,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">pthread_t</span> t[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">2</span>)&#123;</span><br><span class="line">			pthread_create(&amp;t[i],<span class="literal">NULL</span>,pleft,<span class="literal">NULL</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			pthread_create(&amp;t[i],<span class="literal">NULL</span>,pright,<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">		pthread_join(t[i],<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_destroy(&amp;mtx);</span><br><span class="line">	pthread_cond_destroy(&amp;cv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notify(signal)用于唤醒等待队列中的一个线程，而broadcast用于唤醒等待队列中的所有线程。具体使用哪个取决于需求和设计，notify(signal)更常见和推荐，因为它通常更高效且能满足大多数情况下的需求。</p>
<blockquote>
<p>在这里使用broadcast而不是signal的原因是：<br>程序开始时R1(第一个pright线程)，R2都睡在条件变量cv上，然后L1执行结束后，cnt为1，释放mtx，但是还没来得及signal R线程，L2此时获得mtx，发现cnt不满足，于是又睡在cv上，然后L1随机signal一个线程，这个线程恰好是L2，L2发现cnt依然不满足，于是继续睡，现在R1R2L2都睡在cv上，最后L1获得mtx，发现条件不满足，也睡在cv上，所有线程都处于wait，出现死锁</p>
</blockquote>
<p>在调用pthread_cond_wait时，线程会在互斥锁mtx的保护下等待条件变量cv的信号，并在接收到信号后重新获得互斥锁，并继续执行。这样可以确保在条件不满足时线程阻塞，并在条件满足时被唤醒。</p>
<blockquote>
<p>在互斥锁以内调用wait会发生：</p>
<ol>
<li>释放互斥锁：线程在调用 <code>pthread_cond_wait</code>时会将互斥锁的所有权释放，这样其他线程可以获取该互斥锁并访问受保护的共享资源。</li>
<li>进入等待状态：线程进入等待状态，并等待条件变量的信号。在等待期间，线程不会继续执行后续的代码。</li>
<li>接收信号并重新获取互斥锁：当另一个线程调用 <code>pthread_cond_signal</code>或 <code>pthread_cond_broadcast</code>来唤醒等待的线程时，该线程会被唤醒，并重新尝试获取互斥锁。</li>
<li>获取互斥锁并继续执行：当等待的线程成功获取互斥锁后，它会从 <code>pthread_cond_wait</code>函数返回，并继续执行后续的代码。</li>
</ol>
</blockquote>
<p>注意到在条件变量的等待循环中，使用了while而不是if来检查条件。这是为了避免虚假唤醒（Spurious Wakeup）的问题。当一个线程被唤醒时，需要重新检查条件是否满足，如果不满足则继续等待。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一种特殊的条件变量，它可以在操作系统上高效地实现，并且避免broadcast的浪费。</p>
<p>P代表sem_wait（sem.acquire）</p>
<p>V代表sem_signal(sem.release)</p>
<h3 id="信号量强弱"><a href="#信号量强弱" class="headerlink" title="信号量强弱"></a>信号量强弱</h3><p>进程从阻塞队列中采用FIFO模式的信号量叫做强信号量</p>
<p>不采用FIFO模式的信号量叫做弱信号量</p>
<h3 id="哲学家吃饭问题"><a href="#哲学家吃饭问题" class="headerlink" title="哲学家吃饭问题"></a>哲学家吃饭问题</h3><p>这里使用经典的哲♂学家吃饭问题进行举例：<br><img src="/../image/concurrency_management/1684740938859.png" alt="1684740938859"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">forks</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;philosopher %d eating\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="keyword">if</span>(!forks[n]&amp;&amp;!forks[(n+<span class="number">1</span>)%<span class="number">5</span>])&#123;</span><br><span class="line">			forks[n]=<span class="number">1</span>;forks[(n+<span class="number">1</span>)%<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">eat</span>(n);</span><br><span class="line">			forks[n]=<span class="number">0</span>;forks[(n+<span class="number">1</span>)%<span class="number">5</span>]=<span class="number">0</span>;</span><br><span class="line">			lock.<span class="built_in">unlock</span>();</span><br><span class="line">			cv.<span class="built_in">notify_all</span>();</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;thread&gt; threads;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">		threads.<span class="built_in">emplace_back</span>(philosopher, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">		thread.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用了互斥锁+条件变量的方法实现哲♂学家吃饭问题，当每个哲学家左手的叉子和右手的叉子都空闲的时候可以吃饭<br>如果只使用普通的互斥锁，那么当五个哲学家都想吃饭的时候，每人都拿起一个叉子，每人都在等待叉子，触发死锁,如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dead Lock</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">left</span><span class="params">(forkMutexes[n])</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (forks[n]) &#123;</span><br><span class="line">			forkCVs[n].<span class="built_in">wait</span>(left);</span><br><span class="line">		&#125;</span><br><span class="line">		forks[n] = <span class="number">1</span>;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">right</span><span class="params">(forkMutexes[(n + <span class="number">1</span>) % <span class="number">5</span>])</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (forks[(n + <span class="number">1</span>) % <span class="number">5</span>]) &#123;</span><br><span class="line">			forkCVs[(n + <span class="number">1</span>) % <span class="number">5</span>].<span class="built_in">wait</span>(right);</span><br><span class="line">		&#125;</span><br><span class="line">		forks[(n + <span class="number">1</span>) % <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">eat</span>(n);</span><br><span class="line">		forks[n] = <span class="number">0</span>;</span><br><span class="line">		forks[(n + <span class="number">1</span>) % <span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">		forkCVs[n].<span class="built_in">notify_one</span>();</span><br><span class="line">		forkCVs[(n + <span class="number">1</span>) % <span class="number">5</span>].<span class="built_in">notify_one</span>();</span><br><span class="line">		left.<span class="built_in">unlock</span>();</span><br><span class="line">		right.<span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且上程序只能同时让一个哲学家吃饭，那如果我们想让更多的哲学家一起吃饭，应该怎么做呢？<br>一种方法就是使用信号量控制进入临界区的线程数量，最多同时让4个哲学家一起吃饭，就可以解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">forks</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;mutex&gt; <span class="title">forkMutexes</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">counting_semaphore <span class="title">sem</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;philosopher %d eating\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		sem.<span class="built_in">acquire</span>();</span><br><span class="line">		<span class="keyword">while</span>(forks[n])</span><br><span class="line">			;</span><br><span class="line">		forkMutexes[n].<span class="built_in">lock</span>();</span><br><span class="line">		forks[n]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(forks[(n+<span class="number">1</span>==<span class="number">5</span>?<span class="number">0</span>:n+<span class="number">1</span>)])</span><br><span class="line">			;</span><br><span class="line">		forkMutexes[(n+<span class="number">1</span>==<span class="number">5</span>?<span class="number">0</span>:n+<span class="number">1</span>)].<span class="built_in">lock</span>();</span><br><span class="line">		forks[(n+<span class="number">1</span>==<span class="number">5</span>?<span class="number">0</span>:n+<span class="number">1</span>)]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">eat</span>(n);</span><br><span class="line">		forks[n]=<span class="number">0</span>;</span><br><span class="line">		forks[(n+<span class="number">1</span>==<span class="number">5</span>?<span class="number">0</span>:n+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">		forkMutexes[n].<span class="built_in">unlock</span>();</span><br><span class="line">		forkMutexes[(n+<span class="number">1</span>==<span class="number">5</span>?<span class="number">0</span>:n+<span class="number">1</span>)].<span class="built_in">unlock</span>();</span><br><span class="line">		sem.<span class="built_in">release</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;thread&gt; threads;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">		threads.<span class="built_in">emplace_back</span>(philosopher, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">		thread.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程是语言层面上提供的一种实现线程同步的方法（C不支持）</p>
<p>管程是一个或一组数据&#x2F;函数&#x2F;方法组成的资源集合，管程的使用与信号量类似，但是更易控制</p>
<p>每次有且只有一个进程可以使用管程中的资源，管程的同步可以使用不同的方法（条件变量&#x2F;通知与广播）</p>
<h2 id="读者-x2F-写者问题"><a href="#读者-x2F-写者问题" class="headerlink" title="读者&#x2F;写者问题"></a>读者&#x2F;写者问题</h2><p>读者写者问题的定义如下：</p>
<ol>
<li>有多个读进程和写进程，读进程只读，写进程只写</li>
<li>读进程不需要排斥读进程，写进程要排斥其他所有进程，包括读进程和写进程</li>
</ol>
<blockquote>
<p>生产者消费者是否可以看成是一个特殊的读者写者问题呢？</p>
<p>不能，生产者不只是一个写进程，他还需要检查和调整缓冲区的指针，还要确保缓冲区没满</p>
<p>消费者也不只是一个读进程，它还要调整缓冲区的指针来表示他已经取走了一个stuff，还要确定缓冲区不为空</p>
</blockquote>
<p>读者写者问题又两种解决方案：</p>
<h3 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h3><p>读者优先就是在每当读进程访问数据区时，只要至少有一个读进程想读，就为读进程保留控制权，但这样可能会造成写进程的饥饿</p>
<h3 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h3><p>写者优先就是当有一个写进程想写的时候，不允许新的读进程继续占有数据区的控制权</p>
<p><img src="/../image/concurrency_management/1688613237478.png" alt="1688613237478"></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>下面三种常见的情况会导致并发程序出错</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="/../image/concurrency_management/1688613451441.png" alt="1688613451441"></p>
<p>死锁产生有四个条件：</p>
<ol>
<li>互斥（Mutual Exclusion）：至少有一个资源被设计成一次只能被一个线程或进程使用，即在一段时间内只能由一个线程或进程独占访问。</li>
<li>占有并等待（Hold and Wait）：一个线程或进程在持有某个资源的同时，又请求其他线程或进程当前占有的资源。</li>
<li>不可抢占（No Preemption）：已经分配给一个线程或进程的资源不能被其他线程或进程强行抢占，只能由持有者主动释放。</li>
<li>循环等待（Circular Wait）：存在一个资源的循环链，即线程或进程之间形成一个循环等待资源的序列。</li>
</ol>
<p>只要不满足四个条件的其中一个，就不会产生死锁<br>但是，四个条件中的前三个都是互斥锁的性质，只有第四个条件还有操作的空间：</p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>死锁预防就是试图设计一种不会产生死锁的系统，来避免死锁出现的可能性</p>
<p>死锁预防一般有两种策略：</p>
<ol>
<li>间接死锁预防：破坏上述四个条件的前三个，即阻止上面三个条件其中任何一个的发生</li>
<li>直接死锁预防：破坏上述四个条件的第四个，即防止循环等待的发生</li>
</ol>
<h4 id="破坏互斥"><a href="#破坏互斥" class="headerlink" title="破坏互斥"></a>破坏互斥</h4><p>事实上，只要想要实现资源的互斥访问，就必须支持互斥，这是不可避免的</p>
<h4 id="破坏占有并等待"><a href="#破坏占有并等待" class="headerlink" title="破坏占有并等待"></a>破坏占有并等待</h4><p>进程一次性请求所有资源，在没有获得所有资源时等待</p>
<p>但是有两个缺点：</p>
<ol>
<li>进程会等待过长时间</li>
<li>进程有时候实现不知道需要哪些资源</li>
</ol>
<h4 id="破坏不可抢占"><a href="#破坏不可抢占" class="headerlink" title="破坏不可抢占"></a>破坏不可抢占</h4><p>可以：</p>
<ol>
<li>进程在获取其他资源失败的时候，主动释放已有的资源</li>
<li>进程在试图获得其他进程占有的资源时，操作系统抢占另一个进程，要求它释放资源（只有在任意两个进程的优先级不同时才能避免死锁）</li>
</ol>
<p>此外，这种方法只有在资源很容易保存和恢复（例如寄存器）时才是高效的</p>
<h4 id="破坏循环等待"><a href="#破坏循环等待" class="headerlink" title="破坏循环等待"></a>破坏循环等待</h4><p>需要设计一个线性的资源申请顺序</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>死锁避免与死锁预防的差距很小，与死锁预防相比，它允许三个必要条件，但是不允许进程到达死锁点，因此死锁避免比死锁预防允许更多的并发。</p>
<p>死锁避免的两个方法：</p>
<ol>
<li>如果一个进程的请求会导致死锁，则不启动该进程</li>
<li>如果一个进程增加的资源请求会导致死锁，则不分配该资源</li>
</ol>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>资源拒绝分配策略，也叫银行家算法。</p>
<p>安全状态：至少存在一个资源序列不会发生死锁（所有进程能够安全运行到结束）</p>
<p>不安全状态：并非安全的一个状态</p>
<p>详细解释见：<a href="https://en.wikipedia.org/wiki/Banker%27s_algorithm">Banker Algorithm</a></p>
<p>死锁避免策略并不能准确地预测死锁，它只能预测死锁的可能性，并且避免发生这种可能性。</p>
<p>死锁避免虽然比死锁预防好，但是它也有如下局限：</p>
<ol>
<li>进程必须声明所需资源的最大数量</li>
<li>进程之间没有关联性，进程的运行顺序</li>
<li>分配的资源数量必须是固定的</li>
<li>占有资源时，进程不能退出</li>
</ol>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>死锁检测不限制资源访问和进程行为，操作系统周期性的执行一个算法来检测死锁</p>
<p>可以每次都检查，也可以隔一段时间检查，每次都检查可以尽快发现死锁，但是也会浪费大量CPU资源</p>
<p>死锁检测算法详细解释见：<a href="https://en.wikipedia.org/wiki/Deadlock_prevention_algorithms">Deadlock Prevention Algorithm</a></p>
<p>检测到死锁之后一般采用如下四种办法恢复死锁（实现复杂度递增：</p>
<ol>
<li>取消所有死锁进程（最常用</li>
<li>将所有死锁进程回滚到之前的某个状态，然后重启所有死锁进程</li>
<li>连续取消死锁进程直到不再存在死锁（每次取消之后必须重新调用死锁检测算法</li>
<li>连续抢占资源直到不再存在死锁（每次抢占之后也要重新调用算法</li>
</ol>
<h2 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>不同的线程访问内存，至少有一个是写，就产生了数据竞争<br>避免数据竞争最好的方法就是上锁，只要不要忘记上锁或者上错了锁，那么数据竞争就不会发生</p>
<h2 id="原子性-x2F-顺序性违反"><a href="#原子性-x2F-顺序性违反" class="headerlink" title="原子性&#x2F;顺序性违反"></a>原子性&#x2F;顺序性违反</h2><p>当忘记上锁的时候，内存的访问就失去了原子性（Atomicicty Violation,AV）<br>当忘记同步的时候，指令执行的顺序就不是我们的预期（Order Violation,OV）</p>
<p>为了避免上述问题，最好的方法就是防御性编程，在程序中多插入几个assertation，可以让debug的过程更轻松</p>
<p>不仅如此，我们还可以使用现有的工具进行运行时检测，例如ThreadSanitizer,MemorySanitizer。都可以帮助我们检查出程序中的漏洞</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++</title>
    <url>/2023/06/25/effective_c++/</url>
    <content><![CDATA[<h2 id="Item-1"><a href="#Item-1" class="headerlink" title="Item 1"></a>Item 1</h2><p><strong>Prefer smart pointers to traditional pointers</strong></p>
<p>consider the following code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;std::string&gt; <span class="title">fn</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;std::string&gt;(<span class="string">&quot;hello smart pointers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> str=<span class="built_in">fn</span>();</span><br><span class="line">	<span class="keyword">auto</span> new_str=std::<span class="built_in">move</span>(str);</span><br><span class="line">	new_str.<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this function <code>fn()</code> returned a <code>unique_ptr&lt;string&gt;</code> , and <code>new_str</code> took the ownership of <code>str</code>,and now <code>str</code> cannot access the string. In the end, we called the <code>reset</code> method to drop the value which the pointer holds.</p>
<h2 id="Item-2"><a href="#Item-2" class="headerlink" title="Item 2"></a>Item 2</h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>http基础</title>
    <url>/2023/07/12/http_basics/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>客户端：发送请求报文的终端</p>
<p>服务端：接受请求报文并进行相应的终端</p>
<p>URL：Uniform Resource Locator统一资源定位符，用于定位互联网上的任意资源</p>
<p>TCP&#x2F;IP协议簇：http需要通过TCP&#x2F;IP协议簇进行传输，TCP&#x2F;IP协议簇分为应用层、传输层、网络层、链路层</p>
<ul>
<li>应用层：为用户提供通信服务，例如FTP、DNS、HTTP</li>
<li>传输层：向上层应用层提供两台计算机之间的通信服务，其中含有两种不同性质的协议：TCP、UDP</li>
<li>网络层：用来处理网络上流动的数据包，数据包是网络上传递的最小单元</li>
<li>链路层：用来处理网络连接的硬件部分，比如操作系统、NIC（Netword Interface Card,网卡）,光纤等</li>
</ul>
<p><img src="/../image/http_basics/1689145295728.png" alt="TCP/IP通信传输流"></p>
<p><img src="/../image/http_basics/1689145343560.png" alt="1689145343560"></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为封装（encapsulate）</p>
<p>IP：这里的IP指的是IP协议，用来将各种数据包发送给对方。IP协议通过IP地址和MAC（Media Access Control Address）地址来工作</p>
<p>IP地址指明被分配的地址，MAC地址指明网卡所属的固定地址。IP地址可以与MAC地址进行配对。IP地址可以更改，MAC地址一般不会更改<br>ARP：Address Resolution Protocol是一种地址解析协议，它可以通过通信方的IP地址反查出MAC地址，IP间的通信依赖MAC地址</p>
<p>DNS：Domain Name System可以通过用户给出的域名解析对应的IP地址</p>
<h1 id="基本HTTP方法"><a href="#基本HTTP方法" class="headerlink" title="基本HTTP方法"></a>基本HTTP方法</h1><p>GET [url] [http ver]</p>
<p>host: xxxx-xxxx</p>
<p>GET用于客户端向服务端发送资源请求，正常返回请求的资源</p>
<hr>
<p>POST [url] [http ver]</p>
<p>host: xxxx-xxxx</p>
<p>Content-Length: xxxx</p>
<p>POST用于服务端向客户端发送消息</p>
<hr>
<p>OPTIONS * [http ver]</p>
<p>host: xxxx-xxxx</p>
<p>OPTIONS用于查询服务端支持的方法</p>
<hr>
<p>HEAD [url] [http ver]</p>
<p>host: xxxx-xxxx</p>
<p>HEAD用于获取关于url相应报文的首部，只获取首部不获取本身，用于确定url是否有效以及资源的更新时间等</p>
<hr>
<p>CONNECT [host] : [port] [http ver]</p>
<p>CONNECT用于与host的port端口建立隧道连接</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>之前的http每次传输完毕都需要断开连接然后重新建立，现在的http都使用了持久连接，即双方都不会在对方没有明确要求断开连接的时候断开连接，提高了传输速度</p>
<h2 id="流水线化"><a href="#流水线化" class="headerlink" title="流水线化"></a>流水线化</h2><p>现在的http在上一个请求没有得到相应的时候也可以进行下一次请求，使得多个请求可以并发执行，提高了传输速度</p>
<p><img src="/../image/http_basics/1689146660506.png" alt="1689146660506"></p>
<h2 id="数据持久化（Cookie）"><a href="#数据持久化（Cookie）" class="headerlink" title="数据持久化（Cookie）"></a>数据持久化（Cookie）</h2><p>由于http是无状态协议，它不会对之前的请求进行记录和管理，为了实现数据持久化就引入了cookie。</p>
<p>每次访问一个没有cookie的服务端，服务端会生成一个cookie并随响应报文返回，然后客户端保存cookie</p>
<p>之后每次发送请求的时候都在报文中加入这个cookie，服务端通过查表核实是哪个用户，cookie中存放的就是用户的个人信息。</p>
<p><img src="/../image/http_basics/1689146719985.png" alt="1689146719985"></p>
<p><img src="/../image/http_basics/1689146726439.png" alt="1689146726439"></p>
<p><img src="/../image/http_basics/1689146759665.png" alt="1689146759665"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>网络</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp bomb lab答案与解析</title>
    <url>/2023/06/15/csapp_bomb/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>首先看一下炸弹的源码，大概就是需要我们通过调试和逆向工程解开炸弹的六个密码，才可以拆除炸弹。<br>于是我们通过 <code>objdump -d bomb &gt; dasm.s</code>将bomb的反汇编代码重定向进入 <code>dasm.s</code>文件，<br>然后通过 <code>xxd bomb &gt; bomb.hex</code>将bomb可执行程序二进制文件转为十六进制，重定向进入 <code>bomb.hex</code>进行查看</p>
<h1 id="Phase1"><a href="#Phase1" class="headerlink" title="Phase1"></a>Phase1</h1><p>如下是phase1的代码片段，他获取我们的输入，然后进入phase1函数进行比较，如果成功就会调用defuse。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">      * Let me know how they did it. */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>打开dasm文件，找到phase1函数的反汇编代码，可以看到：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          	<span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line">  400ee4:	be <span class="number">00</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       	<span class="keyword">mov</span>    <span class="number">$0</span>x402400,%esi</span><br><span class="line">  400ee9:	e8 4a <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401338</span> &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	<span class="number">85</span> c0                	<span class="keyword">test</span>   %eax,%eax</span><br><span class="line">  400ef0:	<span class="number">74</span> <span class="number">05</span>                	<span class="keyword">je</span>     400ef7 &lt;phase_1+<span class="number">0x17</span>&gt;</span><br><span class="line">  400ef2:	e8 <span class="number">43</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          	<span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要掌握一个知识：函数调用时前6个参数分别放在寄存器：<code>%rdi</code>,<code>%rsi</code>,<code>%rdx</code>,<code>%rcx</code>,<code>%r8</code>,<code>%r9</code>中，<br>返回值放在寄存器:<code>%rax</code></p>
</blockquote>
<p> 因为前面我们知道将input传入了phase1，那么 <code>%rdi</code>中存放的就是input，接下来 <code>mov    $0x402400,%esi</code>将一个地址放入了 <code>%rsi</code>作为第二个参数，然后去调用了 <code>strings_not_equal</code>函数</p>
<p> 如果这个函数的名字没有说谎（我们可以通过调试和反汇编来辨别，这里函数名并没有说谎，所以跳过此步骤），那么他就是用来判断我们的输入和 <code>0x402400</code>指向的字符串是否相等，如果相等，会在 <code>%rax</code>返回 <code>0</code></p>
<p> 接着 <code>je     400ef7 &lt;phase_1+0x17&gt;</code>就会跳转，跳过 <code>callq  40143a &lt;explode_bomb&gt;</code>，然后顺利通过phase1</p>
<p>于是我们在地址空间中搜索地址 <code>0x402400</code>，找到了以 <code>6f 72 64</code>开头的字符串，去十六进制文件中搜索这个数字，就会发现：<br><img src="/../image/csapp_bomb/1686790412428.png" alt="1686790412428"></p>
<p>显而易见，答案就是： <code>Border relations with Canada have never been better.</code></p>
<p>输入答案，顺利通过phase1!</p>
<h1 id="Phase2"><a href="#Phase2" class="headerlink" title="Phase2"></a>Phase2</h1><p>如下是phase2的c源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment"> * how to defuse this... */</span></span><br><span class="line">input = read_line();</span><br><span class="line">phase_2(input);</span><br><span class="line">phase_defused();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	<span class="number">55</span>                   	<span class="keyword">push</span>   %rbp</span><br><span class="line">  400efd:	<span class="number">53</span>                   	<span class="keyword">push</span>   %rbx</span><br><span class="line">  400efe:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          	<span class="keyword">sub</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line">  400f02:	<span class="number">48</span> <span class="number">89</span> e6             	<span class="keyword">mov</span>    %rsp,%rsi</span><br><span class="line">  400f05:	e8 <span class="number">52</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:	<span class="number">83</span> 3c <span class="number">24</span> <span class="number">01</span>          	cmpl   <span class="number">$0</span>x1,(%rsp)</span><br><span class="line">  400f0e:	<span class="number">74</span> <span class="number">20</span>                	<span class="keyword">je</span>     400f30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line">  400f10:	e8 <span class="number">25</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb <span class="number">19</span>                	<span class="keyword">jmp</span>    400f30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line"> </span><br><span class="line">  400f17:	8b <span class="number">43</span> fc             	<span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbx),%eax</span><br><span class="line">  400f1a:	<span class="number">01</span> c0                	<span class="keyword">add</span>    %eax,%eax</span><br><span class="line">  400f1c:	<span class="number">39</span> <span class="number">03</span>                	<span class="keyword">cmp</span>    %eax,(%rbx)</span><br><span class="line">  400f1e:	<span class="number">74</span> <span class="number">05</span>                	<span class="keyword">je</span>     400f25 &lt;phase_2+<span class="number">0x29</span>&gt;</span><br><span class="line">  400f20:	e8 <span class="number">15</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line">  400f25:	<span class="number">48</span> <span class="number">83</span> c3 <span class="number">04</span>          	<span class="keyword">add</span>    <span class="number">$0</span>x4,%rbx</span><br><span class="line">  400f29:	<span class="number">48</span> <span class="number">39</span> eb             	<span class="keyword">cmp</span>    %rbp,%rbx</span><br><span class="line">  400f2c:	<span class="number">75</span> e9                	<span class="keyword">jne</span>    400f17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line">  400f2e:	eb 0c                	<span class="keyword">jmp</span>    400f3c &lt;phase_2+<span class="number">0x40</span>&gt;</span><br><span class="line"> </span><br><span class="line">  400f30:	<span class="number">48</span> <span class="number">8d</span> 5c <span class="number">24</span> <span class="number">04</span>       	<span class="keyword">lea</span>    <span class="number">0x4</span>(%rsp),%rbx</span><br><span class="line">  400f35:	<span class="number">48</span> <span class="number">8d</span> 6c <span class="number">24</span> <span class="number">18</span>       	<span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rbp</span><br><span class="line">  400f3a:	eb <span class="built_in">db</span>                	<span class="keyword">jmp</span>    400f17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line"> </span><br><span class="line">  400f3c:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          	<span class="keyword">add</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line">  400f40:	5b                   	<span class="keyword">pop</span>    %rbx</span><br><span class="line">  400f41:	<span class="number">5d</span>                   	<span class="keyword">pop</span>    %rbp</span><br><span class="line">  400f42:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>上面是phase2的反汇编，我们看到这个函数调用了 <code>read_six_number</code>，读取六个数字，如下是反汇编：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          	<span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">401460</span>:	<span class="number">48</span> <span class="number">89</span> f2             	<span class="keyword">mov</span>    %rsi,%rdx</span><br><span class="line">  <span class="number">401463</span>:	<span class="number">48</span> <span class="number">8d</span> 4e <span class="number">04</span>          	<span class="keyword">lea</span>    <span class="number">0x4</span>(%rsi),%rcx</span><br><span class="line">  <span class="number">401467</span>:	<span class="number">48</span> <span class="number">8d</span> <span class="number">46</span> <span class="number">14</span>          	<span class="keyword">lea</span>    <span class="number">0x14</span>(%rsi),%rax</span><br><span class="line">  40146b:	<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>       	<span class="keyword">mov</span>    %rax,<span class="number">0x8</span>(%rsp)</span><br><span class="line">  <span class="number">401470</span>:	<span class="number">48</span> <span class="number">8d</span> <span class="number">46</span> <span class="number">10</span>          	<span class="keyword">lea</span>    <span class="number">0x10</span>(%rsi),%rax</span><br><span class="line">  <span class="number">401474</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>          	<span class="keyword">mov</span>    %rax,(%rsp)</span><br><span class="line">  <span class="number">401478</span>:	4c <span class="number">8d</span> 4e 0c          	<span class="keyword">lea</span>    <span class="number">0xc</span>(%rsi),%r9</span><br><span class="line">  40147c:	4c <span class="number">8d</span> <span class="number">46</span> <span class="number">08</span>          	<span class="keyword">lea</span>    <span class="number">0x8</span>(%rsi),%r8</span><br><span class="line">  <span class="number">401480</span>:	be c3 <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	<span class="keyword">mov</span>    <span class="number">$0</span>x4025c3,%esi</span><br><span class="line">  <span class="number">401485</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	<span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">  40148a:	e8 <span class="number">61</span> f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:	<span class="number">83</span> f8 <span class="number">05</span>             	<span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax</span><br><span class="line">  <span class="number">401492</span>:	7f <span class="number">05</span>                	<span class="keyword">jg</span>     <span class="number">401499</span> &lt;read_six_numbers+<span class="number">0x3d</span>&gt;</span><br><span class="line">  <span class="number">401494</span>:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401499</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          	<span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line">  <span class="number">40149d</span>:	c3                   	retq  </span><br></pre></td></tr></table></figure>

<p> 我们对调用过程进行分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">phase_2</span><span class="params">()</span>&#123;</span><br><span class="line">    rsi=rsp;</span><br><span class="line">    rsp-=<span class="number">24</span>;</span><br><span class="line">    rdx=rsi;</span><br><span class="line">    rcx=rsi+<span class="number">4</span>;</span><br><span class="line">    rax=rsi+<span class="number">20</span>;</span><br><span class="line">    *(rsp+<span class="number">8</span>)=rax;</span><br><span class="line">    rax=rsi+<span class="number">16</span>;</span><br><span class="line">    *(rsp)=rax;</span><br><span class="line">    r9=rsi+<span class="number">12</span>;</span><br><span class="line">    r8=rsi+<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 也就是rdx,rdx+4,rdx+8.rdx+12,rdx+16(放在rsp指向的地址),rdx+20(放在rsp+8的地址)分别作为scanf使用的六个int的地址。</p>
<p><img src="/../image/csapp_bomb/1686792639904.png" alt="1686792639904"></p>
<p>最后以这样的上下文去调用scanf，而通过rsi中的地址我们得到字符串 <code>%d %d %d %d %d %d</code>，也就是输入6个int，<br>c语言描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">phase_2</span><span class="params">(<span class="type">char</span>*input)</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">6</span>];</span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>,&amp;arr[<span class="number">0</span>],&amp;arr[<span class="number">1</span>],&amp;arr[<span class="number">2</span>],&amp;arr[<span class="number">3</span>],&amp;arr[<span class="number">4</span>],&amp;arr[<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">5</span>)explode_bomb();</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>]!=<span class="number">1</span>)explode_bomb();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]!=<span class="number">2</span>*arr[i<span class="number">-1</span>])&#123;</span><br><span class="line">            explode_bomb();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们只需要保证输入的第一个数字是1，后续的每个数字都是前面一个数字的两倍即可，也就是 <code>1 2 4 8 16 32</code></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>gdb</tag>
        <tag>调试</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>http报文与状态码</title>
    <url>/2023/07/13/http_request/</url>
    <content><![CDATA[<h1 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h1><p>报文分为客户端发出的<strong>请求报文</strong>和服务端回复的<strong>响应报文</strong></p>
<h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p><img src="/../image/http_request/1689238801236.png" alt="1689238801236"></p>
<p>报文一般有一个首部+空行（回车+换行）+报文主体组成，并不一定要有报文主题</p>
<p>请求行包含使用的方法、url和http版本</p>
<p>状态行包含响应的状态码、原因短语和http版本</p>
<p>首部字段包含请求和相应的各种信息，包含请求首部、响应首部、通用首部、实体首部</p>
<p>实体就是原始信息，报文说的就是经过编码的原始信息</p>
<h2 id="传输方法"><a href="#传输方法" class="headerlink" title="传输方法"></a>传输方法</h2><p>当传输大量数据的时候可以使用<strong>分块传输编码</strong>，每次传输一小块，可以让浏览器逐步显示所有内容</p>
<p>分块传输编码会在每块前面加一个hex标记大小，在结尾加一个回车+换行</p>
<h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><p>为了支持断线重连，可以每次请求内容的一小部分然后记录下来</p>
<p>比如Range: byte -3000, 5000-7000</p>
<p>就表示要下载前3kb和第5至7kb之间的内容</p>
<p>如果成功就会返回状态码206 和原因 Partial Content</p>
<p>如果服务器不支持请求范围就会返回200 和 OK，以及全部内容</p>
<h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>为了让不同用户看到自己语言版本的网页，可以使用<strong>内容协商</strong>技术</p>
<p>内容协商就是客户端和服务端之间进行协商并返回最适合的内容</p>
<p>内容协商分为服务器驱动协商、客户端驱动协商和透明协商</p>
<p>服务器驱动协商就是请求的首部为参考，返回相应的内容</p>
<p>客户端驱动协商就是用户可以从浏览器的内容列表中手动选择</p>
<p>透明协商是上面两者的结合</p>
<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><p>我们知道http请求响应报文也会附赠一个状态码用来表示这次请求的状态</p>
<p><img src="/../image/http_request/1689240134954.png" alt="1689240134954"></p>
<h2 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h2><p>2xx表示这次请求被服务器正确处理了</p>
<p>下面是常见的状态码</p>
<p>200 表示成功，并返回请求内容</p>
<p>204 No Content</p>
<p>206 Partial Content</p>
<h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h2><p>3xx表示返回的内容需要进一步处理</p>
<p>下面是常见的状态码</p>
<p>301 Moved Permanently</p>
<p>永久性重定向表示这个url表示的资源已经被移动到了另一个url，需要使用新的url访问</p>
<p>302 Found</p>
<p>临时重定向表示这个资源已经被分配了新的url，希望用户使用新的url访问</p>
<h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h2><p>4xx状态码标明是客户端导致了这次资源访问错误</p>
<p>常用状态码：</p>
<p>400 Bad Request</p>
<p>表示客户端的请求有语法错误，服务器无法理解</p>
<p>401 Unauthorized</p>
<p>表示客户端没有通过http认证</p>
<p>403 Forbidden</p>
<p>这个状态码表示服务器禁止客户端访问这个资源，一般是由于未获得文件系统的访问授权、或者访问权限出现问题</p>
<p>404 Not Found</p>
<p>表示服务器上不存在这个资源或者服务器拒绝了服务而且不想提供原因</p>
<h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h2><p>表示服务器是这次资源访问错误的原因</p>
<p>常用状态码：</p>
<p>500 Internal Server Error</p>
<p>表示服务器在执行请求时发生了错误，也可能表示web端出现的bug或者服务器的故障</p>
<p>503 Server Unavailable</p>
<p>表示服务器正在超负荷或者进行停机维护</p>
<p>最后，状态和返回的状态码不一定严格一致，这只是一个可能</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>http报文首部</title>
    <url>/2023/07/14/http_header/</url>
    <content><![CDATA[<p>http报文首部用来控制http协议中交换的信息、客户端的、服务器的行为</p>
<p>报文首部包含通用首部、请求首部、响应首部、实体首部</p>
<p>每个首部包含很多字段、每个字段中可以写很多指令，指令之间需要使用 <code>,</code> 隔开</p>
<blockquote>
<p>当报文中存在多个相同字段的时候，产生的行为是未定义的，可能使用最先出现的字段，也可能使用最后出现的字段，这取决于浏览器的实现</p>
</blockquote>
<p>下面只列举了通常的字段，字段的指令可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MozillaWebDoc</a>查询</p>
<h1 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h1><p><img src="/../image/http_header/1689305345483.png" alt="1689305345483"></p>
<p>使用via是为了可以对报文进行追踪，以及可以防止传递回环</p>
<h1 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h1><p><img src="/../image/http_header/1689305387840.png" alt="1689305387840"></p>
<h1 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h1><p><img src="/../image/http_header/1689305395689.png" alt="1689305395689"></p>
<p><img src="https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/delta/blog/source/image/http_header/1689305432156.png" alt="1689305432156"></p>
<h1 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h1><p><img src="/../image/http_header/1689305439835.png" alt="1689305439835"></p>
<h1 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h1><p><img src="/../image/http_header/1689309665228.png" alt="1689309665228"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>日语初级</title>
    <url>/2023/07/12/jp_learning/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="五十音"><a href="#五十音" class="headerlink" title="五十音"></a>五十音</h3><p><img src="/../image/jp_learning/1689172195257.png" alt="1689172195257"></p>
<p>平假名&#x2F;片假名五十音图</p>
<h3 id="浊音-x2F-拗音"><a href="#浊音-x2F-拗音" class="headerlink" title="浊音&#x2F;拗音"></a>浊音&#x2F;拗音</h3><p>浊音图：</p>
<p><img src="/../image/jp_learning/1689172265073.png" alt="1689172265073"></p>
<p>拗音图：</p>
<p><img src="/../image/jp_learning/1689172318289.png" alt="1689172318289"></p>
<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>中国人　ちゅうごくじん　４　中国人</p>
<p>日本人　にほんじん　４　日本人</p>
<p>韓国人　かんこくじん　４　韓国人</p>
<p>アメリカ人　あめりかじん　４　アメリカ人　american</p>
<p>フランス人　ふらんすじん　４　フランス人    french</p>
<p>学生　がくせい　０　学生</p>
<p>留学生　りゅうがくせい　3　留学生</p>
<p>教授　きょうじゅ　０　教授</p>
<p>社員　しゃいん　１　社員</p>
<p>会社員　かいしゃいん　3　会社員</p>
<p>店員　てんいん　0　店員</p>
<p>研修生　けんしゅうせん　3　研修生</p>
<p>企業　きぎょう　１　企業</p>
<p>大学　だいがく　０　大学</p>
<p>父　ちち　１　父</p>
<p>課長　かちょう　０　課長</p>
<p>社長　しゃちょう　０　社長</p>
<p>出向　でむかい　０　出迎え</p>
<p>り　李</p>
<p>おう 王</p>
<p>ちょう 张</p>
<p>もり 0 森</p>
<p>はやし 0 林</p>
<p>おの 0 小野</p>
<p>よしだ 0 吉田</p>
<p>たなか 0 田中</p>
<p>なかむら 0 中村</p>
<p>たろう 1 太郎</p>
<p>キム 1 金</p>
<p>ぢゅぽん　ぢゅぽん 迪蓬</p>
<p>スミス　すみす 史密斯</p>
<p>ジョンソン　じょんそん 约翰逊</p>
<p>中国　ちゅうごく　１　中国</p>
<p>東京大学　とうきょうだいがく　５　東京大学</p>
<p>北京大学　ぺきんだいがく　4　北京大学</p>
<p>北京旅行ゃ　ぺきんりょこうしゃ 北京旅行社</p>
<p>につちゅうしょうじ 日中商社</p>
<p>ジェイ式額　JCきがく JC会社</p>
<p>こんにちは　１　你好</p>
<p>すみません　４ 对不起</p>
<p>どうぞ　１ 请</p>
<p>～さん 先生</p>
<p>はじめまして 4 初次见面</p>
<p>こちらこそ 4  我才是</p>
<p>そうです 1 是</p>
<p>ちがいます 4 不是</p>
<p>わかりません 5 不知道</p>
<h4 id="grammar"><a href="#grammar" class="headerlink" title="grammar"></a>grammar</h4><p>A　わ、B　でし      は之前用来提示主题</p>
<p>わたしは，がくせいでし。我是学生</p>
<p>私は、学生でし。</p>
<p>A是B</p>
<hr>
<p>A　わ、B　ではありません　（では　ー＞　じゃ）前者比较正式</p>
<p>わたしは、にほんじんではありません</p>
<p>私は、日本人ではありません 我不是日本人</p>
<p>A不是B</p>
<hr>
<p>Aは、Bですか</p>
<p>あなたはおのですか 你是小野吗 - はい、そうです。</p>
<p>あなたは小野ですか　ー　いええ、ちがいます。</p>
<p>A是B吗</p>
<hr>
<p> AのA</p>
<p>おうさんは　ぺきんだいがくのがくせんです</p>
<p>王さんは　北京大学の学生です</p>
<hr>
<p>李さんは　JCきがくのしゃいんです</p>
<p>森さんは　日本人ですか</p>
<p>はい、そうです</p>
<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="words-1"><a href="#words-1" class="headerlink" title="words"></a>words</h2><p>ほん　１　书</p>
<p>かばん　０  包，公文包</p>
<p>のーと　１  笔记本</p>
<p>えんぴつ  0 铅笔</p>
<p>かさ  1 伞</p>
<p>くつ  鞋</p>
<p>しんぶん</p>
<p>ざっし</p>
<p>じしょ</p>
<p>かめら</p>
<p>てれぴ</p>
<p>ぱそこん</p>
<p>らじお</p>
<p>でんわ</p>
<p>つくえ</p>
<p>いす</p>
<p>かぎ</p>
<p>とけい</p>
<p>てちょう</p>
<p>しゃしｎ</p>
<p>くるま</p>
<p>じてんしゃ</p>
<p>おまやげ</p>
<p>めいさんひん</p>
<p>しるく</p>
<p>はんかち</p>
<p>かいしゃ</p>
<p>かた</p>
<p>ひと</p>
<p>かぞく</p>
<p>はは</p>
<p>おかあさん</p>
<p>にほんご</p>
<p>ちゅうごくご</p>
<p>これ</p>
<p>それ</p>
<p>あれ</p>
<p>どれ</p>
<p>なん</p>
<p>だれ</p>
<p>どなた</p>
<p>この</p>
<p>その</p>
<p>あの</p>
<p>どの</p>
<p>ええ</p>
<p>ながしま</p>
<p>にほん</p>
<p>すわとう</p>
<p>ろんどん</p>
<p>おいくつ</p>
<p>なんさい</p>
<p>スミスさんわ誰ですか</p>
<p>これは私のパスコンです</p>
<p>李さんのパスコンはどれですか</p>
]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>日语初级</tag>
      </tags>
  </entry>
  <entry>
    <title>IEEE754标准的浮点数表示</title>
    <url>/2023/03/27/float_in_IEEE754/</url>
    <content><![CDATA[<h1 id="结构介绍"><a href="#结构介绍" class="headerlink" title="结构介绍"></a>结构介绍</h1><p>因为计算机中只能离散的保存数据，那么数据的最小位就决定了数据精度。<br>例如：</p>
<ul>
<li>表示整数(int)类型时，最小位是$2^0&#x3D;1$,因此精度就是1，int类型无法保存任何模1不等于0的数。</li>
</ul>
<p>而小数却不存在最小位（无穷小），因此IEEE协会制定了一种用于表示浮点数的存储方式。<br>已知：</p>
<blockquote>
<p>任何十进制的数都可以表示为$n&#x3D;(-1)^s<em>M</em>10^E$的形式</p>
</blockquote>
<p>其中s是符号位,n为负数时s为0，n为正数时s为1，m是一个尾数，位于1~10之间，e是幂次。例如：$12345&#x3D;(-1)^0<em>1.2345</em>10^4$.</p>
<p>同理：</p>
<blockquote>
<p>任何二进制数都可以表示为$n&#x3D;(-1)^s<em>M</em>2^E$的形式</p>
</blockquote>
<p>符号含义：</p>
<ul>
<li>s:符号(sign)</li>
<li>M:尾数(significand)</li>
<li>E:阶码(exponet)</li>
<li>同时，我们用m代表M中存储的值，e表示E中存储的值。</li>
</ul>
<p>所以，如果我们要存储2进制浮点数，只需要存储s、M、E的值即可。<br>由上述公式可知，m位于1~2之间，因此其最高位总是为1，我们将其省略。</p>
<p>此外，为了存储e为负数的浮点数，对于E有k位的浮点数，还存在一个<strong>偏置</strong> $Bias &#x3D; 2^{k-1}-1$,E最终的值要加上偏置后再进行存储。</p>
<p>以32位float为例：</p>
<p><img src="/../img/floatStructure.png" alt="float的具体结构"><br>这样，我们就有了表示浮点数的方法。</p>
<h1 id="值的表示"><a href="#值的表示" class="headerlink" title="值的表示"></a>值的表示</h1><p>这种表示浮点数的方式有三种情况：</p>
<ul>
<li><p><strong>规格化的值</strong><br>E中的位不全为0，也不全为1。<br>此时n可以由$(-1)^s*(1+m)*2^{e-Bias}$计算得出。</p>
</li>
<li><p><strong>非规格化的值</strong><br>因为我们假定M始终大于1，所以我们无法表示0.<br>而当<strong>阶码E全为0</strong>时，浮点数表示非规格化的值，它为我们提供了表示0的方法，此时<strong>阶数&#x3D;1-Bias</strong>。<br>例如：<br>0 00000000 0000000… 表示+0.0<br>1 00000000 0000000… 表示-0.0<br>根据IEEE的浮点格式，+0与-0在某些方面是不同的，而在其他方面是相同的。<br>非规格化数的另一种功能是表示非常接近于0的值。</p>
</li>
<li><p><strong>特殊值</strong><br>最后一类数值是当<strong>阶码E全为1</strong>是出现的。</p>
<p>当小数域全为0时，表示<strong>无穷</strong><br>当小数域不为0时，表示<strong>NaN</strong>（Not a Number）</p>
<p>例如当两个非常大的数相乘，或者除以0时，会产生无穷。<br>当一些运算不能是实数或者无穷时，例如无穷加无穷：返回NaN</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>信息的表示与处理</tag>
        <tag>浮点数</tag>
        <tag>浮点</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc与gdb的基本使用</title>
    <url>/2023/06/14/gcc_gdb/</url>
    <content><![CDATA[<h1 id="gcc的基本使用"><a href="#gcc的基本使用" class="headerlink" title="gcc的基本使用"></a>gcc的基本使用</h1><p>g++的使用方法与gcc基本完全一致，这里只介绍gcc，g++的使用只需要将gcc换为g++即可</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><code>gcc file1 file2 -o prog</code></p>
<p>这里gcc会将file1与file2都进行编译然后进行链接，形成可执行文件prog</p>
<h2 id="分步编译"><a href="#分步编译" class="headerlink" title="分步编译"></a>分步编译</h2><p>我们都知道，从代码到可执行程序需要经历预处理、编译、汇编、链接四个步骤</p>
<p>我们可以使用 <code>gcc file -E/-S/-c -o out.i/.s/.o</code>分别对文件进行预处理、编译、汇编三个动作，并分别产生后缀为.i&#x2F;.s&#x2F;.o的文件</p>
<p>当然，我们也可以对上一步产生的文件继续处理，例如；</p>
<p><code>gcc obj1.o obj2.o -o prog</code></p>
<p>这里我们对两个目标文件进行了链接，产生了prog的可执行程序</p>
<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><p>编译器通常会对我们的代码进行优化以达到最高的效率</p>
<p>我们可以使用 <code>gcc -Og/-O1/-O2/-O3</code>分别对代码进行0级优化（不优化），1&#x2F;2&#x2F;3级优化（优化强度逐渐增加）</p>
<p>此外，如果我们需要使用gdb对我们的程序进行调试，就需要使用 <code>gcc -g</code>显式的生成debug版文件，其中包含着可以供我们使用的调试信息</p>
<p>使用 <code>gcc -ggdb</code>来产生gdb使用的调试信息</p>
<h2 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h2><p>如果需要编译某一版本的代码，可以使用 <code>-std=...</code>来指定使用的那个c语言&#x2F;c++版本，例如-std&#x3D;c11、-std&#x3D;c++23</p>
<p>如果需要链接某些库，就需要使用 <code>-l...(lib_name)</code>来链接指定名字的库，例如 -lname意味着你在默认路径下面链接了名为libname.so的动态库</p>
<p>如果你对自己的程序不是很有信心，你可以使用 <code>gcc -Wall</code>让编译器产生所有的警告信息来帮助你找bug</p>
<p>而如果你是一个牛逼的程序员，那么你应该使用 <code>gcc -w</code>来无视所有的编译器警告</p>
<h1 id="gdb的基本使用"><a href="#gdb的基本使用" class="headerlink" title="gdb的基本使用"></a>gdb的基本使用</h1><p> 使用gdb启动程序</p>
<p>   <code>gdb ./your_program</code></p>
<h2 id="展示代码"><a href="#展示代码" class="headerlink" title="展示代码"></a>展示代码</h2><ol>
<li>打印当前往下十行<br><code>list</code></li>
<li>展示源代码TUI<br><code>layout src</code></li>
<li>展示反汇编TUI<br><code>layout asm</code></li>
</ol>
<h2 id="设置断点-括号内是可选内容"><a href="#设置断点-括号内是可选内容" class="headerlink" title="设置断点(括号内是可选内容)"></a>设置断点(括号内是可选内容)</h2><ol>
<li>在（某一文件）某一行设置断点<br><code>break (file_name:)line_number</code></li>
<li>在（某一文件）某一函数设置断点<br><code>break (file_name:)function_name</code></li>
<li>同样的，我们可以删除断点<br><code>delete 1</code>(删除断点1)</li>
<li>禁用断点<br><code>disable</code></li>
<li>启用断点<br><code>enable</code></li>
</ol>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><ol>
<li>运行程序<br><code>run</code></li>
<li>执行一行<br><code>next</code></li>
<li>执行一步<br><code>step</code></li>
<li>执行一句指令<br><code>stepi</code> + num（执行num条指令）</li>
<li>执行至下个断点<br><code>continue</code></li>
<li>执行至某一行<br><code>until</code></li>
<li>执行直到函数结束<br><code>finish</code></li>
</ol>
<h2 id="打印值"><a href="#打印值" class="headerlink" title="打印值"></a>打印值</h2><ol>
<li>打印表达式exp，单个变量也是一种表达式<br><code>print exp</code><br>这里我们可以使用任何东西作为这个exp，例如一个寄存器，内存引用，甚至是一个函数</li>
<li>我们也可以直接对变量进行设置<br><code>set variable</code></li>
<li>在每次执行停止的时候都打印exp的值<br><code>display exp</code></li>
<li>解除打印<br><code>undisplay number</code></li>
</ol>
<blockquote>
<p>tips: 使用 <code>/x</code>打印16进制，<code>/d</code>打印10进制，<code>/t</code>打印2进制<br>寄存器使用 <code>$</code>符号+寄存器名字 表示，e.g.  <code>$rax</code></p>
</blockquote>
<h2 id="查看调用栈"><a href="#查看调用栈" class="headerlink" title="查看调用栈"></a>查看调用栈</h2><p>使用 <code>traceback</code> 查看程序的调用栈</p>
<h2 id="查看程序信息"><a href="#查看程序信息" class="headerlink" title="查看程序信息"></a>查看程序信息</h2><p>使用 <code>info</code>查看程序的状态信息，例如寄存器 <code>info registers</code>，函数 <code>info function</code>，断点信息 <code>info breakpoint</code></p>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p>输入 <code>quit</code>退出gdb并杀死子进程</p>
<h1 id="RTFM"><a href="#RTFM" class="headerlink" title="RTFM"></a>RTFM</h1><p>Read The Fucking Manual (</p>
<p>使用 <code>man/help</code>指令获取gcc&#x2F;gdb手册</p>
]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>调试</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础</title>
    <url>/2023/07/04/linux_basics/</url>
    <content><![CDATA[<h2 id="linux基本指令"><a href="#linux基本指令" class="headerlink" title="linux基本指令"></a>linux基本指令</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>short for list</p>
<p>ls [path] [options]</p>
<p>打印某个目录（默认是工作目录）下的文件&#x2F;目录</p>
<p>常用选项：</p>
<ul>
<li>-a 打印隐藏文件</li>
<li>-l 打印更多信息（ls -l 可简写为ll）</li>
<li>-d 将文件夹像文件一样显示</li>
<li>-t 以时间排序</li>
<li>-R 列出子目录下的文件</li>
</ul>
<hr>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>short for print working directory</p>
<p>打印工作目录</p>
<hr>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>short for change directory</p>
<p>cd [path]</p>
<p>更换工作目录</p>
<p>linux中使用 <code>.</code>表示当前目录， <code>..</code>表示上级目录， <code>/</code>表示根目录</p>
<p><code>cd ~</code>切换到用户目录</p>
<p><code>cd -</code>切换到上一个工作目录</p>
<hr>
<h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p>stat [file]</p>
<p>用于展示文件属性(size&#x2F;access&#x2F;modify&#x2F;change&#x2F;uid&#x2F;gid)</p>
<hr>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>用于更改文件的access&#x2F;modify&#x2F;change时间，也可以用于创建文件</p>
<blockquote>
<p>access时间是访问权限，理论上是最常被更改的，但是为了减少磁盘IO设置为了隔一段时间更改一次</p>
<p>modify是修改文件内容的时间</p>
<p>change是修改文件属性的时间（文件属性一般包括权限、大小等）</p>
</blockquote>
<p>touch [file] [options]</p>
<p>常用选项:</p>
<ul>
<li>-a 更改access时间，同时也会修改change</li>
<li>-t 使用特定的时间，不是当前时间（日期格式：）</li>
</ul>
<hr>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>mkdir [path&#x2F;name]</p>
<p>在path路径下创建一个name名字的文件夹</p>
<p>常用选项：</p>
<ul>
<li>-p（–parent）递归创建文件夹</li>
</ul>
<hr>
<h3 id="rmdir-amp-rm"><a href="#rmdir-amp-rm" class="headerlink" title="rmdir&amp;rm"></a>rmdir&amp;rm</h3><p>rm [path&#x2F;name]</p>
<p>删除文件&#x2F;目录</p>
<p>常用选项：</p>
<ul>
<li>-r 递归删除</li>
<li>-f 强制删除不询问</li>
<li>-i 交互删除询问</li>
</ul>
<p>ps：rmdir只能删除空文件夹</p>
<hr>
<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>short for manual</p>
<p>大名鼎鼎的RTFM</p>
<p>man [index] [command]</p>
<p>常用目录：</p>
<ul>
<li>1 linux指令页</li>
<li>2 系统调用页</li>
<li>3 c库函数页</li>
<li>8 系统管理指令页</li>
</ul>
<p>常用选项：</p>
<ul>
<li>-a 从所有目录中查找</li>
</ul>
<hr>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>short for copy</p>
<p>copy [file] [path]</p>
<p>复制文件file到路径path下</p>
<p>常用选项：</p>
<ul>
<li>-r 递归处理子文件和目录</li>
<li>-i 交互询问是否覆盖文件</li>
<li>-f 强制拷贝并覆盖</li>
</ul>
<hr>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>short for move</p>
<p>mv [source&#x2F;name] [destination&#x2F;name]</p>
<p>从source路径移动到destination路径</p>
<p>也可以用于文件改名</p>
<p>常用选项与cp一致</p>
<hr>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>cat [path&#x2F;name]</p>
<p>常用选项：</p>
<ul>
<li>-b 对非空输出行编号</li>
<li>-n 对输出的所有行编号</li>
<li>-s 不输出多行空行</li>
</ul>
<hr>
<h3 id="head-amp-tail"><a href="#head-amp-tail" class="headerlink" title="head&amp;tail"></a>head&amp;tail</h3><p>查看文件前&#x2F;后 n行</p>
<p>head&#x2F;tail -number [file]</p>
<hr>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>常用选项：</p>
<ul>
<li>-i  忽略搜索时的大小写</li>
<li>-N  显示每行的行号</li>
<li>&#x2F;字符串：向下搜索“字符串”的功能</li>
<li>?字符串：向上搜索“字符串”的功能</li>
<li>n：重复前一个搜索（与 &#x2F; 或 ? 有关）</li>
<li>N：反向重复前一个搜索（与 &#x2F; 或 ? 有关）</li>
<li>q:quit</li>
</ul>
<hr>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find [path&#x2F;name] [options]</p>
<p>在文件树中查找文件</p>
<p>常用选项：</p>
<ul>
<li>-name 根据名字查找文件</li>
</ul>
<p>例如： <code>find /home/deltamaya -name test.c</code></p>
<p>查找deltamaya家目录下名为test.c的文件</p>
<hr>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>short for global regular expression</p>
<p>grep [options] [target] [file]</p>
<p>常用选项：</p>
<ul>
<li>-i ：忽略大小写的不同，所以大小写视为相同</li>
<li>-n ：顺便输出行号</li>
<li>-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行</li>
</ul>
<p>例如：<code>grep -n fork fork.cc</code></p>
<p>在fork.cc文件中使用正则表达式搜索fork字符串，并且输出行号</p>
<hr>
<h3 id="zip-amp-unzip"><a href="#zip-amp-unzip" class="headerlink" title="zip&amp;unzip"></a>zip&amp;unzip</h3><p>例子：</p>
<p><code>zip -r test.zip test.asm test.c test.o</code></p>
<p><code>unzip -f test.zip</code></p>
<hr>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>文件的压缩和解压</p>
<p>常用选项：</p>
<ul>
<li>-c ：建立一个压缩文件的参数指令(create 的意思)；</li>
<li>-x ：解开一个压缩文件的参数指令！</li>
<li>-t ：查看 tarfile 里面的文件！</li>
<li>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？</li>
<li>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？</li>
<li>-v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！</li>
<li>-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！</li>
<li>-C ： 解压到指定目录</li>
</ul>
<p>例子：</p>
<p><code>tar -zcv test.c test.o -f test.tar.gz</code></p>
<p>将test.c test.o打包并使用gz压缩为test.tar.gz</p>
<p><code>tar -xvf test.tar.gz -C ./d1</code></p>
<p>从test.tar.gz中解压放入d1目录中</p>
<hr>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>date +[format]</p>
<p>格式：</p>
<ul>
<li>%H : 小时(00..23)</li>
<li>%M : 分钟(00..59)</li>
<li>%S : 秒(00..61)</li>
<li>%X : 相当于 %H:%M:%S</li>
<li>%d : 日 (01..31)</li>
<li>%m : 月份 (01..12)</li>
<li>%Y : 完整年份 (0000..9999)</li>
<li>%F : 相当于 %Y-%m-%d</li>
</ul>
<hr>
<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>cal [year]</p>
<p>打印年year的日历</p>
<hr>
<h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p>获取当前系统的信息</p>
<p>常用选项：</p>
<ul>
<li>-a 展示全部信息</li>
</ul>
<hr>
<h3 id="mount-amp-umount"><a href="#mount-amp-umount" class="headerlink" title="mount&amp;umount"></a>mount&amp;umount</h3><p>挂载&#x2F;卸载文件系统</p>
<hr>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>展示网络信息</p>
<hr>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>展示cpu占用</p>
<hr>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>展示内存占用</p>
<hr>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>chmod [options] [expression] [file]</p>
<p>exp可以使用a&#x2F;u&#x2F;g&#x2F;o +&#x2F;- r&#x2F;w&#x2F;x</p>
<p>或者只用三个八进制数字</p>
<p>更改文件访问权限</p>
<hr>
<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>更改文件所属组</p>
<hr>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>查看权限掩码</p>
<hr>
<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户</p>
<hr>
<h3 id="rz-amp-sz"><a href="#rz-amp-sz" class="headerlink" title="rz&amp;sz"></a>rz&amp;sz</h3><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul>
<li>d：文件夹</li>
<li>-：普通文件</li>
<li>l：软链接（类似Windows的快捷方式）</li>
<li>b：块设备文件（例如硬盘、光驱等）</li>
<li>p：管道文件</li>
<li>c：字符设备文件（例如屏幕等串口设备）</li>
<li>s：套接口文件</li>
</ul>
<h2 id="vim基本使用"><a href="#vim基本使用" class="headerlink" title="vim基本使用"></a>vim基本使用</h2><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><ul>
<li>按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；</li>
<li>按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；</li>
<li>按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。<br>从插入模式切换为命令模式<br>按「ESC」键。</li>
</ul>
<h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><ul>
<li>vim可以直接用键盘上的光标来上下左右移动，但正规的vim是用小写英文字母「h」、「j」、「k」、<br>「l」，分别控制光标左、下、上、右移一格</li>
<li>按「G」：移动到文章的最后</li>
<li>按「 $ 」：移动到光标所在行的“行尾”</li>
<li>按「^」：移动到光标所在行的“行首”</li>
<li>按「w」：光标跳到下个字的开头</li>
<li>按「e」：光标跳到下个字的字尾</li>
<li>按「b」：光标回到上个字的开头</li>
<li>按「#l」：光标移到该行的第#个位置，如：5l,56l</li>
<li>按［gg］：进入到文本开始</li>
<li>按［shift＋g］：进入文本末端</li>
<li>按「ctrl」+「b」：屏幕往“后”移动一页</li>
<li>按「ctrl」+「f」：屏幕往“前”移动一页</li>
<li>按「ctrl」+「u」：屏幕往“后”移动半页</li>
<li>按「ctrl」+「d」：屏幕往“前”移动半页</li>
</ul>
<h4 id="删除文字"><a href="#删除文字" class="headerlink" title="删除文字"></a>删除文字</h4><p>「x」：每按一次，删除光标所在位置的一个字符<br>「#x」：例如，「6x」表示删除光标所在位置的“后面（包含自己在内）”6个字符<br>「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符<br>「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符<br>「dd」：删除光标所在行<br>「#dd」：从光标所在行开始删除#行</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>「yw」：将光标所在之处到字尾的字符复制到缓冲区中。<br>「#yw」：复制#个字到缓冲区<br>「yy」：复制光标所在行到缓冲区。<br>「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。<br>「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完<br>成复制与粘贴功能。</p>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>「r」：替换光标所在处的字符。<br>「R」：替换光标所到之处的字符，直到按下「ESC」键为止。</p>
<h4 id="撤销上一次操作"><a href="#撤销上一次操作" class="headerlink" title="撤销上一次操作"></a>撤销上一次操作</h4><p>「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次“u”可以执行多次回<br>复。<br>「ctrl + r」: 撤销的恢复</p>
<h4 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h4><p>「cw」：更改光标所在处的字到字尾处<br>「c#w」：例如，「c3w」表示更改3个字</p>
<h4 id="跳至指定的行"><a href="#跳至指定的行" class="headerlink" title="跳至指定的行"></a>跳至指定的行</h4><p>「ctrl」+「g」列出光标所在行的行号。<br>「#G」：例如，「15G」，表示移动光标至文章的第15行行首。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2023/06/24/process_and_thread/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程可以理解为一个正在执行中的程序的实例，现代的CPU可以在不同进程之间进行快速切换，达成在某个时间之内多个进程同时在运行的错觉（伪并行），这种快速的切换叫做<strong>多道程序设计</strong>，而<strong>多处理器系统</strong>则是有多个CPU同时使用内存，这是真正的硬件并行</p>
<p>单个处理器可以被若干进程共享，它使用某种<strong>调度算法</strong>来决定何时该停止一个工作。</p>
<p>此外，一个进程运行了两次的话，他依然算作两个进程，操作系统使他们共享源码，因此只有一份代码放在内存中。</p>
<p>进程在内存中一般有如下几个组成：</p>
<p>地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息</p>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>何时会发生进程创建？</p>
<p><img src="/../image/process_and_thread/1688553171955.png" alt="1688553171955"></p>
<p>进程可以分为前台进程和后台进程。</p>
<p>还有一种后台进程大部分时间都在睡眠，当某些请求到达时会被唤醒，叫做守护进程</p>
<p>在UNIX中提供了 <code>fork()</code>系统调用用来创建一个子进程，给父进程返回子进程的pid，给子进程返回0</p>
<p>进程创建之后，父进程和子进程拥有不同的地址空间</p>
<p>当操作系统创建新进程时，会执行以下步骤：</p>
<ol>
<li>分配进程控制块（Process Control Block，PCB）：操作系统为新进程分配一个数据结构，称为进程控制块（PCB）。PCB用于存储和管理进程的相关信息，包括进程状态、标识符、优先级、程序计数器、寄存器值、内存分配、打开文件列表等。</li>
<li>分配虚拟地址空间：操作系统为新进程分配虚拟地址空间。虚拟地址空间是进程独立的内存空间，用于存储进程的代码、数据和堆栈。根据进程的需求和操作系统的内存管理策略，分配的虚拟地址空间可能是连续的或分散的。</li>
<li>加载程序：操作系统根据新进程的可执行文件或程序映像，将程序的指令和数据加载到进程的虚拟地址空间中。这包括将程序的可执行代码加载到代码段、初始化数据加载到数据段，并为堆栈分配空间。</li>
<li>初始化进程上下文：操作系统会初始化新进程的上下文，包括设置程序计数器（PC）指向程序的入口点，设置栈指针（SP）指向堆栈的起始位置，初始化寄存器等。这样，在执行新进程时，CPU将从程序的入口点开始执行。</li>
<li>设置进程状态：操作系统将新进程的状态设置为就绪状态（Ready），表示它已准备好执行，并可以被调度。</li>
<li>将新进程添加到进程调度队列：操作系统将新进程添加到适当的进程调度队列中，以便调度器可以选择合适的时间将处理器分配给该进程。</li>
<li>返回到调用者：操作系统将控制权返回给创建新进程的调用者。通常，创建进程的系统调用在创建进程完成后会返回新进程的标识符或进程句柄，以便调用者可以继续执行其他任务。</li>
</ol>
<p>这些步骤可以根据操作系统的实现和特定需求有所不同，但通常包括了进程控制块的分配、地址空间的分配和加载、上下文初始化、状态设置和进程调度等关键操作，以确保新进程能够被操作系统正确管理和调度。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断会打断当前程序的运行，中断发生时，将当前程序跳转到一个中断处理程序（interrupt service）中，用来处理这个中断的事件。例如IO完成时会调用IO中断，中断处理程序就会设置IO的各个属性，使之能够继续接受作业。</p>
<p><img src="/../image/operating_system_intro/1688550603814.png" alt="1688550603814"></p>
<p>虽然为了实现中断需要在每个指令周期内去判断中断是否发生，看起来减慢了程序的执行速度，但实际上中断可以提高程序的实行效率</p>
<p><img src="/../image/operating_system_intro/1688551212736.png" alt="1688551212736"></p>
<p>看这个图中，第一个IO操作开始时，IO设备会给处理器发送中断信号，打断处理器等待IO结束的过程，转而去执行2a操作，IO结束时也会发送中断信号，让处理器返回继续执行刚才的程序5</p>
<p><img src="/../image/process_and_thread/1688551639905.png" alt="1688551639905"></p>
<p>我们可以看到，中断执行时处理器会将PSW和PC压入系统控制栈，这是在为进程切换做准备。</p>
<p>图中，保存完PSW和PC之后会从中断向量装入这类中断对应的中断处理程序的地址，每类中断都有一个中断处理程序</p>
<p>最后，我们应该为中断设置优先级，来实现高效的多级中断</p>
<h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>在以下情况进程会终止：</p>
<p><img src="/../image/process_and_thread/1688553207017.png" alt="1688553207017"></p>
<p>出错退出是指进程自己发现了非法操作，自己调用 <code>exit</code>退出程序</p>
<p>严重错误是指进程没有发现的错误，比如除数是0，操作系统会自动结束这个出错进程</p>
<h2 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h2><p>在UNIX中，进程和他的所有子进程成为一个<strong>进程组</strong></p>
<p>UNIX在启动时，会初始化一个init进程，init被载入内存映像之后，接受一个说明终端数量的文件，接着，为每个终端创建一个新进程</p>
<p>Windows中没有子进程的概念，唯一相似的概念是在进程创建一个新进程之后会返回一个<strong>进程句柄</strong>，父进程可以使用这个句柄对子进程进行控制</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>进程有运行态，就绪态和挂起态</p>
<p><img src="/../image/process_and_thread/1688553351031.png" alt="1688553351031"></p>
<p>运行态就是正在处理器中运行的</p>
<p>就绪态就是还处于内存中，但是正在等待CPU</p>
<p>挂起态就是因为内存空间不够了，导致部分进程需要从内存转移到硬盘，挂起进程不能立即执行</p>
<p>为了阻止某个进程执行，可以通过某个代理将这个进程挂起，这个代理可以是进程本身，也可以是父进程</p>
<p><img src="/../image/process_and_thread/1688553328943.png" alt="1688553328943"></p>
<p>操作系统的最底层是调度程序，在它上面有许多进程。</p>
<h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><p>操作系统维护了一张<strong>进程表</strong>，每个进程就是一个表项，也叫PCB（进程控制块）</p>
<p><img src="/../image/process_and_thread/1688553089909.png" alt="1688553089909"></p>
<p>每个表项中有这些属性：</p>
<ol>
<li>进程管理<ol>
<li>寄存器</li>
<li>PC</li>
<li>堆栈指针</li>
<li>程序状态字</li>
</ol>
</li>
<li>储存管理<ol>
<li>正文段指针</li>
<li>数据段指针</li>
<li>堆栈段指针</li>
</ol>
</li>
<li>文件管理<ol>
<li>根目录</li>
<li>文件描述符</li>
<li>用户ID</li>
<li>组ID</li>
</ol>
</li>
</ol>
<p>此外，操作系统还维护了一张<strong>内存表</strong>、一张<strong>IO表</strong>和一张<strong>文件表</strong></p>
<p><img src="/../image/process_and_thread/1688554225634.png" alt="1688554225634"></p>
<p>其中，内存表用来记录哪些内存，哪些外存分配给了进程，以及每个内存块的保护属性</p>
<p>IO表用来记录每个IO设备和通道的属性，每个表项要么正在被使用，要么可以使用</p>
<p>文件表，由文件系统维护和使用，记录每个文件是否存在、在外存中的位置、以及文件属性</p>
<p>每一类中断都关联了一个中断向量的位置，它包含中断服务程序的入口</p>
<p>所有的中断都从保存寄存器开始，如下是一个中断的大致过程：</p>
<ol>
<li>硬件压入堆栈PC等</li>
<li>硬件从中断向量装入新的PC</li>
<li>汇编语言过程保存寄存器</li>
<li>汇编语言过程设置新堆栈</li>
<li>C中断服务例程运行</li>
<li>调度程序决定下一个运行的程序</li>
<li>C过程返回值汇编代码</li>
<li>汇编语言过程开始运行新的进程</li>
</ol>
<h2 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h2><p><img src="/../image/process_and_thread/1688554499757.png" alt="1688554499757"></p>
<p>进程的属性集叫做进程控制块PCB（也叫PCB）</p>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>进程控制块是操作系统中最重要的数据结构，它包含操作系统需要的所有的进程信息</p>
<p>进程控制块信息分为：</p>
<p>进程标识信息</p>
<p>进程状态信息</p>
<p>进程控制信息</p>
<p><img src="/../image/process_and_thread/1688554777394.png" alt="1688554777394"></p>
<p>进程的代码、数据、栈和属性的集合叫做进程映像</p>
<p>所以<strong>进程映像</strong>由进程的<strong>代码、数据、堆栈和进程的PCB</strong>组成</p>
<h2 id="处理器状态信息"><a href="#处理器状态信息" class="headerlink" title="处理器状态信息"></a>处理器状态信息</h2><p>进程在运行的过程中，它的代码和数据一定会出现在寄存器中，所以中断发生的时候也需要保存进程的寄存器，等终端结束的时候用来恢复进程的执行状态。</p>
<p>寄存器主要分为<strong>用户可见寄存器</strong>、<strong>控制和状态寄存器</strong>和<strong>栈指针</strong></p>
<p>每个处理器结构都维护一个或者一组<strong>程序状态字</strong>寄存器（PSW），用来条件码和进程的状态</p>
<p><img src="/../image/process_and_thread/1688555296730.png" alt="1688555296730"></p>
<h2 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h2><p>抢占一个进程是指操作系统中的调度器强制终止当前正在执行的进程，并将处理器（CPU）分配给另一个优先级更高的进程。这意味着正在执行的进程被中断，其当前状态被保存，并将处理器分配给具有更高优先级的进程，以确保系统能够及时响应重要的任务或事件。</p>
<p>抢占通常是由操作系统内核中的调度算法控制的，该算法根据进程的优先级、时间片（每个进程被允许使用处理器的时间量）和其他调度策略来决定何时抢占一个进程。</p>
<p>抢占可以发生在以下情况下：</p>
<ol>
<li>时间片用尽：当进程的时间片（时间配额）用尽时，操作系统会中断该进程，并将处理器分配给下一个进程。</li>
<li>优先级提升：如果存在具有更高优先级的进程，并且操作系统决定将处理器分配给该进程，那么当前正在执行的进程将被抢占。</li>
<li>中断处理：当系统接收到硬件中断（如计时器中断、输入&#x2F;输出中断等）或软件中断（如系统调用或异常）时，操作系统可能会抢占正在执行的进程，以处理中断事件。</li>
</ol>
<p>通过抢占，操作系统可以灵活地管理系统资源，并确保重要的任务或事件能够及时得到处理，提高系统的响应能力和效率。</p>
<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>在计算机操作系统中，交换（Swapping）是指将当前不活动的进程或进程的部分内容从主存（RAM）中移出，保存到辅助存储器（如硬盘）中，以释放主存空间给其他进程使用。当需要再次运行这些被交换出的进程时，可以将其重新调入主存，继续执行。</p>
<p>交换的主要目的是优化系统资源的利用和管理，具有以下几个重要的意义：</p>
<ol>
<li>内存管理：通过交换，操作系统可以在有限的主存容量下同时运行更多的进程。当主存空间不足时，将不活动的进程交换到辅助存储器中，从而释放出宝贵的主存空间，以便其他活动进程能够继续执行。</li>
<li>多任务处理：交换允许操作系统在多任务环境下有效地进行进程调度。当某个进程处于等待某些事件（如用户输入、磁盘读写等）而暂停执行时，可以将其交换出主存，执行其他就绪的进程，以提高系统的并发性和吞吐量。</li>
<li>延展性：交换可以扩展系统的可用内存。辅助存储器通常比主存容量更大，通过将不活动的进程交换出主存，可以在需要时将其调入，实现对更多进程的支持。</li>
<li>系统性能：通过交换，操作系统可以更好地管理进程的内存需求。将不活动的进程交换出主存可以减少主存的碎片化，提高内存利用率，并降低页面调度和页面替换的频率，从而提高系统的整体性能。</li>
</ol>
<p>需要注意的是，交换也会引入一定的开销，包括交换进程的时间和系统开销。因此，交换的决策需要综合考虑系统的性能需求、主存和辅助存储器的速度差异以及进程的活动程度等因素。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程间通信有很多方法，例如：管道、共享内存、信息、信号量、信号、套接字</p>
<h1 id="进程的执行"><a href="#进程的执行" class="headerlink" title="进程的执行"></a>进程的执行</h1><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>进程可以运行在用户态和内核态</p>
<p>用户进程往往运行在用户态，内核态指操作系统的内核</p>
<p>在内核态下，进程可以完全控制指令、硬件、寄存器，这对用户程序来说是没有必要的。</p>
<p>使用两种模式的原因是为了保护操作系统中的重要数据（比如进程表&#x2F;进程控制块）</p>
<p>进程通过自己PSW中的模式位来判断自己的运行状态。这个位会因为事件而改变</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进程切换可以发生在操作系统取得控制权的任意时刻</p>
<p>首先考虑系统中断。</p>
<p>系统中断可以分为中断和陷阱，前者与某种外部事件有关，比如完成IO，后者与进程本身执行的操作有关，比如文件非法访问</p>
<p>对于普通中断，进程在保存完上下文之后，将控制权首先转移给中断处理器，中断处理器完成一些简单操作之后将控制权转移给与中断类型有关的特定的操作系统中断处理例程</p>
<p><img src="/../image/process_and_thread/1688555884892.png" alt="1688555884892"></p>
<p>而对于陷阱，操作系统首先会判断是否致命，如果致命就结束进程。如果不致命，操作系统的行为取决于错误的类型和操作系统的设计，操作系统可能会尝试恢复进程，也可能会继续执行或者切换进程。</p>
<p>最后，来自运行态的进程的系统调用也可以激活操作系统。比如一个进程调用了IO输入的命令，此时调用会转移到操作系统中代码的一个例程，之前的进程被置为阻塞态。</p>
<h2 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h2><p>在中断检查的时候，如果没有中断，CPU会继续取指执行。</p>
<p>而如果发生了中断，就需要将PC改为中断处理程序的起始地址，然后将用户态置为内核态（PSW中</p>
<p>然后中断处理程序的第一条指令就是保存进程的上下文，也就是所有可能会被修改的数据，以及恢复进程时所需要的所有数据。这些数据包括寄存器，堆栈、和PCB</p>
<p>模式切换可在不改变运行态进程状态的情况下发生，此时保存进程上下文和恢复进程开销很小</p>
<p>中断不一定会造成进程切换</p>
<p>完整的进程切换过程：</p>
<ol>
<li>保存进程上下文（寄存器、PC</li>
<li>更新进程PCB，将运行态置为另一种状态。更新其他字段，比如退出运行态的原因和记账信息</li>
<li>将PCB移到对应队列（就绪&#x2F;挂起&#x2F;阻塞在i处</li>
<li>分配器选择另一个进程执行</li>
<li>更新PCB，设置为运行态</li>
<li>更新内存管理数据结构。是否需要更新取决于管理地址转换的方式（更新段表&#x2F;页表）</li>
<li>载入新进程的上下文</li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程在内存中主要有如下内容：</p>
<p>PC、寄存器、堆栈、状态</p>
<p>可以看出，线程就是轻量版的进程，他只分配计算资源</p>
<p>一个进程可以有多个线程，这几个线程共用进程的资源（内存），但是单独执行自己的计算任务</p>
<p>总之，进程用于把资源集中到一起，线程则是在CPU上被调度执行的实体</p>
<p><strong>多线程</strong>一般用于描述一个进程中使用了多个线程，每个线程都有自己的堆栈</p>
<h2 id="线程的实现方法"><a href="#线程的实现方法" class="headerlink" title="线程的实现方法"></a>线程的实现方法</h2><p>有两种主要的方法实现线程包，在用户空间和内核中</p>
<h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>在用户空间中实现线程包，内核不知道有线程的存在</p>
<p>优点是：用户级线程包可以在不支持线程的操作系统上实现（现代操作系统基本都支持线程）</p>
<p>用户空间的线程需要进程在运行时提供一个系统，用来管理线程</p>
<p>这个系统就需要维护一个线程表，用于记录线程的PC、堆栈、寄存器和状态位等</p>
<p>并且用户级线程切换不需要陷入内核，不需要上下文切换，速度比内核级线程快了不止一个数量级</p>
<p>支持每个进程都有自己的调度算法</p>
<p>但是，用户级线程也有如下缺点：</p>
<p>当一个线程发生页面故障时，整个进程都会陷入IO中断，导致其他没有发生页面故障的程序也被置为阻塞态</p>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>内核级线程的实现使得进程不再需要维护一个运行时系统和线程表</p>
<p>在当线程希望创建一个新线程或者撤销一个已有线程时，他会进行一个系统调用，陷入内核，所以当线程操作比较多，就会带来很大开销</p>
<p>内核级的线程表保存的东西与用户级线程相同</p>
<p>最后，线程可以注册自己感兴趣的信号，当这些信号到达的时候，可把他交给需要他的线程</p>
<p>总之，多线程并不能在没有频繁发生阻塞的应用中显著提高运行速度，只有在频繁进行系统调用的程序中，多线程可以显著提高运行速度,用于提高并发量</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用户级线程的优点：</p>
<ol>
<li>线程切换不需要进入内核，省去了两次模式切换的时间</li>
<li>在任何操作系统上都可以运行，不需要操作系统提供线程支持</li>
<li>每个进程可以有自己的调度算法</li>
</ol>
<p>用户级线程的缺点：</p>
<ol>
<li>因为操作系统看不见用户级线程，所以每次只会将一个进程分配给一个处理器，也就是每次只能执行一个线程</li>
<li>一个线程的阻塞会导致整个进程的阻塞</li>
</ol>
<blockquote>
<p>可以使用“套管”技术解决上述缺点，“套管”就是将一个会产生阻塞的系统调用转换为一个不会产生阻塞的系统调用，将会阻塞的系统调用传递给一个套管例程去执行</p>
</blockquote>
<p>内核级线程的缺点：</p>
<ol>
<li>即使在同一个进程中的线程进行切换，也需要进入内核</li>
</ol>
<p><img src="/../image/process_and_thread/1688611140838.png" alt="1688611140838"></p>
<p>可以看出，ULT和KLT，KLT和进程之间的性能有一个数量级以上的差距。</p>
<p>但是也需要看实际的程序，如果一个程序之中的线程切换总是在进程之间的切换，ULT不见得会比KLT好</p>
<h1 id="进程间通信-1"><a href="#进程间通信-1" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>进程之间可以通过信息传递通信，这种通信方法使用两条原语send和receive</p>
<h3 id="信息传递系统的要点"><a href="#信息传递系统的要点" class="headerlink" title="信息传递系统的要点"></a>信息传递系统的要点</h3><p>在信息传递中会发生信息丢失，这时候就需要进程之间进行确认</p>
<p>消息系统还需要解决进程命名问题，同时，身份认证也是一个问题</p>
<p>最后，将消息从一个进程复制到另一个进程通常比信号量操作和进入管程要慢</p>
<h3 id="信箱"><a href="#信箱" class="headerlink" title="信箱"></a>信箱</h3><p>进程之间也可以通过信箱进行通信，在发送和接收信息时，都将目标进程的地址改为信箱的地址，这样可以降低系统的耦合性</p>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>可以通过在多个进程结束的位置设置一个屏障，当单个进程到达屏障时他必须等待其他进程，知道所有进程都抵达屏障位置，所有进程同时穿越屏障。屏障可用于进程同步。</p>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>进程的调度同样适用于线程的调度</p>
<p>所有的调度算法都需要具有如下属性：</p>
<ol>
<li>公平（给每个进程公平的CPU份额）</li>
<li>策略强制执行（保证规定的策略被执行</li>
<li>平衡（保持系统的所有部分都忙碌</li>
</ol>
<h2 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h2><ol>
<li>在创建一个新的进程，需要决定是运行父进程还是子进程</li>
<li>要给进程退出的时候必须做出调度决策</li>
<li>当一个进程阻塞在IO或者信号量或者其他东西上时，必须选择另一个进程运行</li>
<li>当一个IO中断发生时，需要进行调度</li>
</ol>
<p>调度算法主要分为两类：</p>
<h3 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h3><p>非抢占式调度算法挑选一个进程，然后让这个进程运行直到被阻塞，或者主动释放CPU</p>
<h3 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h3><p>抢占式调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值</p>
<h2 id="调度算法分类"><a href="#调度算法分类" class="headerlink" title="调度算法分类"></a>调度算法分类</h2><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><h4 id="先到先服务"><a href="#先到先服务" class="headerlink" title="先到先服务"></a>先到先服务</h4><p>这就是最简单的调度算法，这个算法的优点是易于理解且便于在程序中使用</p>
<p>但是这个调度算法会导致运行时间很短的任务需要等待运行时间长的任务，这是不可接受的</p>
<h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>因此人们发明了最短作业优先算法，这个算法可以让平均等待时间降到最短</p>
<p>只有在所有作业都可同时运行的情况下，最短作业优先才是最优的</p>
<h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><h4 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h4><p>每个进程被分配一个时间片，当进程的时间片使用完之后，调度到队列中的下一个进程</p>
<p>进程切换，又叫上下文切换</p>
<p>当时间片设置的太短会导致进程切换频繁，降低性能，而设置的太长又会让短的交互请求等待时间过长。</p>
<p>通常将时间片设置为20-50ms</p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>优先级调度就是在轮转调度的基础上加入了优先级，操作系统总是轮转执行最高优先级上的进程</p>
<p>一般运行之后需要对优先级进行调整，否则会发生低优先级进程的饥饿</p>
<h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>这个调度算法需要根据进程之前使用时间片的情况对进程的运行时间进行估计，估计时间最短的进程优先执行</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统简介</title>
    <url>/2023/06/23/operating_system_intro/</url>
    <content><![CDATA[<h1 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h1><p>操作系统就是计算机硬件与软件交互的媒介，软件通过操作系统执行<strong>系统调用</strong>，操作系统根据设备的驱动程序操作底层硬件。</p>
<p>操作系统对软硬件资源进行抽象和管理。</p>
<h2 id="计算机硬件介绍"><a href="#计算机硬件介绍" class="headerlink" title="计算机硬件介绍"></a>计算机硬件介绍</h2><p>我们都知道计算机有四大组成：控制器、运算器、存储器、IO设备</p>
<h3 id="处理器（控制器-运算器）"><a href="#处理器（控制器-运算器）" class="headerlink" title="处理器（控制器+运算器）"></a>处理器（控制器+运算器）</h3><p>可以先看一下这篇博客，点击下面链接对处理器有一个初步了解：</p>
<p><a href="https://deltamaya.top/2023/05/10/CPU/">处理器</a></p>
<p>在执行指令时，为了获得硬件服务，软件需要通过<strong>系统调用</strong>向操作系统申请，此时用户程序就会陷入到<strong>内核态</strong>并调用操作系统。</p>
<h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><p>这里要额外介绍一下GPU，我们都知道CPU可以通过多核提高运行速度。</p>
<p>而GPU就是在一个芯片上安装了大量（通常上万）的微核，这些微核都只能进行简单的运算，但是由于数量巨大，使得GPU十分擅长于大量并行的简单运算，比如图像处理。但是GPU不擅长CPU的串行处理，也就不适合编程、更不适合运行操作系统了。</p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>内存 （Random Access Memory, RAM）：可随机读写，断电内容消失</p>
<p>只读存储器（Read Only Memory，ROM）：只能读不能写，用于加载计算机启动模块</p>
<p>磁盘（硬盘）：存储大量数据，读写速度慢</p>
<p>虚拟内存：通过逻辑地址映像为物理地址，将程序常用部分存储在内存，使可用内存大大增加</p>
<h2 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程本质上就是正在执行的一个程序</p>
<p>它具有自己的地址空间，在地址空间中可以存放进程的代码、数据、堆栈等，进程可以在这个地址空间中进行读写</p>
<p>进程还具有自己的资源集，比如各个寄存器、打开文件的清单等</p>
<p>进程本身就是一个存放程序所需信息的容器</p>
<p>在真实的系统中，往往有多个进程同时运行。这就需要操作系统维护一份进程表，进程表是数组或链表结构，每一个节点中存放一个进程的相关信息。</p>
<p>一个挂起的进程的地址空间叫做进程的磁芯映像，还有对应的进程表项。</p>
<p>一个进程可以创建另一个进程，叫做子进程。</p>
<p>进程之间可以进行通信。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>进程需要放在内存中。进程可以使用的内存空间叫做进程的地址空间。</p>
<p>CS：段寄存器</p>
<p>IP：偏移</p>
<p>这个空间从物理内存被抽象为了逻辑地址（由一个唯一的数字表示），可以使进程使用一个数字来访问内存，也可以通过起始地址和偏移量来访问特定内存。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件系统就是一个多叉树</p>
<p>每个文件或者文件夹都有自己的路径，路径可以分为绝对路径和相对路径</p>
<p>每个进程都有一个工作目录，相对路径会使用这个工作目录来表示</p>
<p>要打开一个文件，先检查访问权限，如果权限许可，返回一个fd（文件描述符），若不许可，返回一个错误码</p>
<p>文件系统之间可以相互链接，例如一个u盘上的文件树可以接到pc文件树的某一个位置</p>
<p>每个文件都有自己独特的id，叫做i-编号，所以，一个目录本质上就是一个包含i-编号和ascii字符串的哈希表</p>
<p>inode 中存放了文件的属性（文件&#x3D;文件内容+文件属性）</p>
<p>我们可以通过link系统调用在目录之间放置某个文件的引用，文件本体和其引用的i-编号相同</p>
<p>特殊文件：用于表示IO设备</p>
<p>分为块特殊文件，又一个个的可以随机存取的块组成的IO</p>
<p>字符特殊文件，可以理解为流文件，比如打印机</p>
<p>管道：管道是一种虚文件，它可以连接两个进程，进程A可以向管道中输出，进程B可以从管道中输入，看上去就像是A的输出作为B的输入</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>为理解系统调用，我们首先需要记住：1.任何单CPU计算机每次只能执行一条指令</p>
<p>2.如果一个用户态进程需要调用系统服务（比如使用IO），那么它就需要执行一个陷阱或系统调用，将控制权转移给操作系统</p>
<p>一个执行系统调用的过程：用户态进程希望进行系统调用，保存自己的上下文（堆栈和寄存器等），PC指向操作系统的代码，此时CPU控制权在操作系统，原进程此时处于阻塞，操作系统执行完毕系统调用之后，恢复进程上下文，PC指向调用操作系统的下一行，进程从内核态转为用户态</p>
<p>调用过程中，调用者需要将系统调用的对应编号存放在寄存器中，执行TRAP，陷入内核，TRAP会将PC跳转到一个固定地址，然后通过之前保存的编号跳转到相应的系统调用的代码</p>
<p>linux中，fork是用于赋值当前进程的系统调用，execve用于替换进程的磁芯映像（地址空间），通过这两个系统调用，就可以新建任何一个进程</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2023/07/02/memory_management/</url>
    <content><![CDATA[<h1 id="为何要进行内存管理"><a href="#为何要进行内存管理" class="headerlink" title="为何要进行内存管理"></a>为何要进行内存管理</h1><p>我们知道，现在的计算机通常都要同时运行多个进程，而进程需要访问数据，数据存放在内存中</p>
<p>那么当我们同时运行两个程序的时候，怎么才能确定两个程序的某些数据不会重叠呢</p>
<p>换言之，怎么才能让两个程序同时运行在内存上而不发生冲突？</p>
<p>所以，内存管理就需要<strong>重定位</strong>，让每次换入换出到不同物理内存位置上的进程可以正常访问。</p>
<p>此外，还需要对进程的地址空间进行<strong>保护</strong>，来放置其他进程有意无意的修改，也可以防止用户进程修改操作系统</p>
<p>有时进程之间需要共享资源，还需要对进程进行<strong>共享</strong>操作。</p>
<h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><p>于是，我们引入了地址空间的概念</p>
<p>地址空间通过实现了<strong>保护</strong>和<strong>重定位</strong>解决了这个问题</p>
<p>这里，每个进程都把自己使用的内存空间进行了分段，每一段都有一个<strong>基地址</strong>和一个<strong>界限大小</strong></p>
<h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p>通过对内存分段，每段有自己的<strong>rwx权限</strong>保护</p>
<p>当用户使用的地址在<strong>基址+界限</strong>之内时表示合法访问</p>
<p>确保在访问内存地址时不会进行非法操作，例如在想要修改数据的时候意外写入到了正文段导致程序崩溃</p>
<p>此外，也可以防止攻击者轻易修改代码进行攻击</p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>分为编译时重定位和运行时重定位，</p>
<h3 id="编译时重定位"><a href="#编译时重定位" class="headerlink" title="编译时重定位"></a>编译时重定位</h3><p>需要在编译时就确定程序需要在那些地址上运行，适合于单一作用的嵌入式系统，而放在真正的计算机上就很难实现</p>
<p>因为有如此多的软件开发商，很难让大家都有序的分配内存</p>
<p>于是我们就要使用运行时重定位</p>
<h3 id="运行时重定位"><a href="#运行时重定位" class="headerlink" title="运行时重定位"></a>运行时重定位</h3><p>就是在运行时对即将访问的地址进行修改，通常使用一个基址寄存器实现，每个段有自己的基址寄存器，在访问内存的时候</p>
<p><strong>逻辑地址+基址&#x3D;物理地址</strong></p>
<p>就可以有序的访问物理地址</p>
<h1 id="链接与加载"><a href="#链接与加载" class="headerlink" title="链接与加载"></a>链接与加载</h1><p><img src="/../image/memory_management/1688693661312.png" alt="1688693661312"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>创建活动进程的第一步就是将进程的代码载入到内存中，叫做加载</p>
<p>加载通常分为：</p>
<h3 id="绝对加载"><a href="#绝对加载" class="headerlink" title="绝对加载"></a>绝对加载</h3><p>绝对加载要求每次加载都把程序加载到内存的固定位置</p>
<p>这就需要程序员事先知道内存的分配策略</p>
<p>此外，当程序中的一个地方修改时，所有的地址都要进行修改</p>
<h3 id="可重定位加载"><a href="#可重定位加载" class="headerlink" title="可重定位加载"></a>可重定位加载</h3><p>因为绝对加载的这些缺陷，引入了可重定位加载</p>
<p>每个进程都通过一个相对地址和基地址来运行</p>
<p>比如要加载到x处，只需要再每个地址前面都加上x即可</p>
<p>为了实现这一点，加载模块需要给加载器提供一些关于地址的信息，这些信息通常通过编译器或者汇编器准备，叫做<strong>重定位地址库</strong></p>
<p><img src="/../image/memory_management/1688694127686.png" alt="1688694127686"></p>
<h3 id="动态运行时加载"><a href="#动态运行时加载" class="headerlink" title="动态运行时加载"></a>动态运行时加载</h3><p>再运行时真正使用某个绝对地址时再去计算这个地址，加载模块在加载到内存中时，所有内存访问都使用相对地址表示</p>
<p><img src="/../image/memory_management/1688693893382.png" alt="1688693893382"></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><img src="/../image/memory_management/1688694275098.png" alt="1688694275098"></p>
<h3 id="链接编辑程序"><a href="#链接编辑程序" class="headerlink" title="链接编辑程序"></a>链接编辑程序</h3><p>在链接过程中，为每个目标文件创建一个文件开始出的引用，然后加载模块，连同加载模块开始使得引用，都被放入一个可重定位的<strong>链接编辑程序</strong></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>某些外部模块的链接也可以推迟到加载模块之后</p>
<p>动态链接的主要步骤：</p>
<p>待加载的模块（应用模块）被载入到内存，应用模块中对外部模块（目标模块）的任何引用都将导致加载程序对目标模块的查找和加载，然后将这些引用改为相对应用模块开始处的相对地址</p>
<p>相对于静态有这些好处：</p>
<ol>
<li>更容易并入已改变或者已升级的目标模块</li>
<li>动态链接文件中的目标代码，为自动代码共享铺平了道路</li>
<li>独立软件开发人员更容易开发扩展程序</li>
</ol>
<p>使用运行时动态链接，可以将某些链接工作推迟到运行时</p>
<p>这些共享的目标模块叫做动态库，windows下叫做dll</p>
<p>当两个不同进程希望链接一个dll库的不同版本，就会导致dll地狱</p>
<hr>
<h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><p>当有一些进程处于阻塞状态时，如果让它一直在内存中，就导致内存使用率降低了</p>
<p>段是程序被人为分割成的几部分，比如代码段、数据段</p>
<p>而我们知道程序分成的段大小不一致，有大有小，如果胡乱进行分配，很容易就会造成内存中很多狭小的缝隙，这些缝隙放不下任何新的段</p>
<p>导致内存的使用率降低，而这些缝隙就叫做<strong>内存碎片</strong>。</p>
<p>当然，我们也可以使用<strong>内存&#x2F;碎片整理</strong>来“压缩”这些内存碎片。但是这样做就需要遍历整个内存，极大的拖慢了运行速度</p>
<p>为了避免内存碎片的产生，我们需要一种优秀的内存分配算法</p>
<h2 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h2><p>此外，为了达成这一点，程序自己必须维护一份自己的段表（LDT）</p>
<h3 id="首次适配算法"><a href="#首次适配算法" class="headerlink" title="首次适配算法"></a>首次适配算法</h3><p>顾名思义，首次适配算法就是在进程的段表中进行遍历，将找到的第一个可以放的下该段的空间，并将段放入其中</p>
<p>这种交换算法的速度很快，因为他尽可能少的遍历节点</p>
<h3 id="下次适配算法"><a href="#下次适配算法" class="headerlink" title="下次适配算法"></a>下次适配算法</h3><p>下次适配算法与首次适配算法的不同是 下次适配算法都从上次搜索重点的结尾继续搜索 ，其他都与首次适配搜索相同。</p>
<p>经过仿真程序证明：下次适配算法在性能上略差于首次适配算法</p>
<h3 id="最佳适配算法"><a href="#最佳适配算法" class="headerlink" title="最佳适配算法"></a>最佳适配算法</h3><p>最佳适配算法会遍历整个链表来找到与当前段大小最匹配的空间，并将当前段放入其中</p>
<p>这种算法运行很慢，因为每次都要遍历整个链表，并且也会带来大量内存碎片</p>
<h3 id="最差适配算法"><a href="#最差适配算法" class="headerlink" title="最差适配算法"></a>最差适配算法</h3><p>与之相对的，最差适配算法会找最不匹配的内存空间来放置当前段</p>
<p>这样虽然可以减少内存碎片，但是依然无法解决运行慢的问题</p>
<h3 id="快速适配算法"><a href="#快速适配算法" class="headerlink" title="快速适配算法"></a>快速适配算法</h3><p>快速适配算法会维护一张常用内存大小的链表，每个节点都存放着一个有着当前大小空间的内存地址</p>
<p>这样虽然可以快速找到可以分配的空间，但是他跟所有将空闲区按大小排序的方案有一个共同的缺点</p>
<p>就是在一个进程终止或者被换出时，寻找他的相邻块并查看是否可以合并时非常耗时的。如果不进行合并，就会产生大量内存碎片</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>尽管我们创建了地址空间抽象，解决了多个程序不能运行的问题，但是依然无法解决应用占用内存膨胀的问题</p>
<p>我们希望在内存中可以尽可能多的运行程序，但是内存的膨胀速度远没有程序所需内存膨胀的速度块</p>
<p>所以就需要使用虚拟内存</p>
<p>根据局部性原理，程序在运行的某一个时期，只会访问某一个部分的数据，而不是全体数据</p>
<p>这就给了我们操作空间——只要将程序当前运行需要的数据放在内存中就好，不需要将整个程序都放在内存中</p>
<p>虚拟内存的基本思想就是：</p>
<blockquote>
<p>每个程序都拥有自己的地址空间，这个空间被分为很多块，称为<strong>页</strong>，每一页有连续的地址范围，这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序</p>
</blockquote>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>操作系统将物理内存分为很多个页，比如一个页可以是4k</p>
<p>操作系统还会维护一张<strong>页表</strong>，用来记录每个页是不是被占用了</p>
<p>在进程眼中，自己拥有整个内存的空间，它会维护一张页表，但是这个页表中存放的是当前页号向操作系统页表页号的映射，以及是否存在</p>
<p>在CPU要访问内存时，先将逻辑地址送往MMU（内存管理单元）进行映射，得到物理地址，再通过物理地址访问内存</p>
<p>如果只有一级映射关系的话，MMU所做的工作就是逻辑地址的页框号映射为物理地址的页框号，然后通过偏移去访问对应页框对应地址的内存</p>
<h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><p>但是当MMU发现进程要访问的逻辑页没有映射到任何一个物理页时，就会引发一个缺页中断</p>
<p>例如：</p>
<p>这里MMU收到了一个逻辑页8，于是他去进程维护的页表中查询8位置对应的物理页，得到了24，但是24号页当前不在内存中，就会引起缺页中断</p>
<p>这意味着在内存中现在不存在进程要访问的东西，需要从磁盘中读取这个数据。而磁盘IO是慢于CPU的，所以进程需要陷入内核进行IO</p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>为了实现分页的功能，页表表项一般长成这样：</p>
<p><img src="/../image/memory_management/1688289818587.png" alt="1688289818587"></p>
<p>这里我们只介绍其中几个</p>
<ol>
<li>Present &#x2F; 出现位<br>这个位告诉我们当前页表是否存在于内存当中</li>
<li>ReadWrite &#x2F;  保护位<br>这个位用来约束rwx权限</li>
<li>Dirty &#x2F; 脏位<br>这个位用来表示当前页是否被修改了，如果被修改了需要写回内存</li>
<li>CacheDisabled &#x2F; 高速缓存禁止位<br>当我们希望读取的数据总是在内存中的最新值而不是从高速缓存中读取，就需要这个位</li>
</ol>
<h2 id="读取策略"><a href="#读取策略" class="headerlink" title="读取策略"></a>读取策略</h2><p>即驻留集管理</p>
<h2 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h2><p>与读取策略不同，清除策略用于确定什么时候将已修改的页写回辅存。</p>
<p>清除策略分为请求式清除和预约式清除</p>
<h3 id="请求式清除"><a href="#请求式清除" class="headerlink" title="请求式清除"></a>请求式清除</h3><p> 只有当一页被用于置换时才被写回辅存</p>
<h3 id="预约式清除"><a href="#预约式清除" class="headerlink" title="预约式清除"></a>预约式清除</h3><p>将这些已修改的页在它们需要使用自己的页框之前就写回辅存</p>
<h3 id="页缓冲"><a href="#页缓冲" class="headerlink" title="页缓冲"></a>页缓冲</h3><p>页缓冲取消了页面置换和清除间的成对关系</p>
<p>被置换页可放在两个表之间，修改表和未修改表</p>
<p>修改表可以周期性的成批写出，放入未修改表</p>
<p>未修改表中的页要么被访问到而被恢复，要么在其页框分配给其他页时被换出</p>
<h2 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h2><p>当内存逐渐增大时，页表会逐渐增大。例如32位机器中，以4k为一个页框的话就会有1m个表项，每个表项占用四个字节（如上图），就需要有4m内存来存放一个页表，而每个进程都需要一个页表，每个进程都至少需要4m来存放一个页表，这是不可接受的</p>
<p>所以我们使用了两种方法加速分页的过程</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>多级页表就类似于看书的时候先通过章的名字大致定位节的位置，然后在某一章的范围内查找某一小节</p>
<p>其中章的页表叫做<strong>页目录表</strong>，节的页表就叫页表（页项必须连续存储，否则查找次数过多性能太差）</p>
<p>我们以二级页表为例：</p>
<p>逻辑地址就不只需要一个逻辑页号了，而是需要一个页表号和一个页号，还有一个偏移</p>
<p>我们先使用页表号去查找对应页表，然后再去对应页表中映射物理页号。</p>
<p>假如这里的页表号和页号都是用10位表示，一共有三个页表，那么总共需要$2^{10}*3$&#x3D;16k的空间来存放页，远远小于之前的4m</p>
<p>实际的系统中（64位），往往需要5~6级页表</p>
<h3 id="TLB（快表）"><a href="#TLB（快表）" class="headerlink" title="TLB（快表）"></a>TLB（快表）</h3><p>虽然使用了多级页表减少了查找次数，但是依然需要查好几次内存，如果想进一步提升性能，就需要使用TLB（转换检测缓冲区）</p>
<p>TLB是一组寄存器，用来存放最近使用的页表映射，TLB可以<em>使用硬件</em>在O1的时间查找所有TLB寄存器</p>
<p>如果TLB hit，直接去内存中查找即可，如果TLB miss就需要查多级页表，然后将这个页表放入TLB</p>
<p>我们可以得到平均访问内存时间$t&#x3D;p*(mem+tlb)+(1-p)<em>(tlb+n</em>mem)$</p>
<p>其中p是TLB hit的概率，mem是访问内存的时间，tlb是访问TLB寄存器的时间，n是多级页表的级数</p>
<p>一般TLB hit的概率都比较高（局部性原理），所以有了TLB，访问目标的时间就能接近于访问一次内存的时间</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，我们知道段是面向用户的，页是面向硬件的。</p>
<p>将段和页结合起来，操作系统就可以实现对内存的管理</p>
<p>首先，程序提供一个逻辑地址（段号+偏移），然后这个逻辑地址会映射到虚拟内存，得到虚拟地址，虚拟内存被分成了很多页，根据虚拟地址去查页表，得到页号和偏移，也就是物理地址，最后根据这个物理地址去物理内存中寻找目标。</p>
<p><img src="/../image/memory_management/1688301082288.png" alt="1688301082288"></p>
<p>一个进程有一个段表和一个页表(但是如果段与段之间没有重合的话，也可以只需要一张页表)，只要建立好了页表和段表，MMU就可以帮助我们做好一切。</p>
<p>在一个进程执行fork的时候，会将地址空间完全复制一份，包括段表和页表。也就是说，它们并没有开辟多个物理内存，只是复制了一份指针。</p>
<p>当其中一个进程想要写某一个位置的时候，会发生<strong>写时复制</strong>，子进程在物理内存上映射一个新的页用来存放自己的这个修改的数据，同时也会修改自己的页表，将映射的页框号改为新申请的这个页。注意，这里段表并不会被修改，虽然父子进程映射在虚存的位置是相同的，但是由于页表不同，映射到物理内存的位置也不同。</p>
<p><img src="/../image/memory_management/1688695347403.png" alt="1688695347403"><img src="/../image/memory_management/1688695404146.png" alt="1688695404146"></p>
<h1 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h1><p>由于虚拟内存的存在，每个进程看到的都是完整的线性物理内存，并且这些内存都是可以使用的。</p>
<p>但是真正的物理内存中，我们知道一个进程绝对没有可能占据所有的物理内存，那这是怎么实现的呢？</p>
<p>局部置换策略就是在发生缺页的进程中选择一个页换出，全局置换策略就是将所有页作为候选页，而不是单单缺页进程的页</p>
<p><img src="/../image/memory_management/1688696474201.png" alt="1688696474201"></p>
<p>其中，可变分配，全局置换被最广泛的采用</p>
<h2 id="内存换入"><a href="#内存换入" class="headerlink" title="内存换入"></a>内存换入</h2><p>实际上，每个进程将自己的所有资源都放在虚拟内存中，但是虚拟内存不一定都要映射在物理内存中，通常值映射一小部分。</p>
<blockquote>
<p>为什么发生缺页中断的时候选择调页而不是调段？</p>
<p>当发生缺页中断时，通常选择调页（page replacement）而不是调段（segment replacement）的原因如下：</p>
<ol>
<li>虚拟内存管理：调页是虚拟内存管理的核心概念之一，而调段并不是常用的虚拟内存管理策略。虚拟内存管理的目标是将进程的地址空间划分为固定大小的页面，以便更高效地管理内存资源。调页是一种粒度较小的管理方式，可以灵活地将进程的页面加载到物理内存中。</li>
<li>空间利用率：调页策略可以更好地利用物理内存资源。页面的大小通常较小（例如4KB），这使得可以在物理内存中更紧凑地组织页面，并更有效地利用可用的物理内存空间。调页可以实现细粒度的内存管理，按需加载和卸载页面，避免一次性加载整个段所需的大量内存。</li>
<li>页面局部性：调页能够更好地利用页面局部性原理。页面局部性是指程序倾向于访问临近的内存地址，而不是随机访问内存。调页策略通过在缺页中断时选择置换最不可能被访问的页面，以期望较少发生未来的缺页中断，从而更好地利用页面局部性。</li>
<li>简化管理：调页比调段更简化了内存管理的复杂性。段的大小可以变化，而且管理可变大小的段会更复杂。调页则可以采用相对固定的页面大小，更容易管理和实现。</li>
</ol>
<p>综上所述，调页作为一种常用的虚拟内存管理策略，更适合应对缺页中断和内存管理的需求。它可以更好地利用内存资源、适应页面局部性，并且相对于调段来说更简化内存管理的复杂性。</p>
</blockquote>
<p>这就会引出一个问题，当我们想访问的东西没有映射到物理内存应该怎么办呢？</p>
<p>通常会发生如下过程：</p>
<ol>
<li>MMU发现某一个页没有映射，产生缺页中断</li>
<li>通过中断向量跳转到缺页中断处理程序</li>
<li>申请新页框，必要的话需要将旧页写回磁盘，这会造成上下文切换</li>
<li>从磁盘中读入该页，放入新页框</li>
<li>建立虚拟内存的映射关系，修改页表</li>
<li>中断返回</li>
</ol>
<p>最重要的中断处理程序实际上就做了其中的第4，5，6步，就可以完成内存页的换入。</p>
<p>在我们想访问任何虚拟内存地址的时候，都可以访问，只不过有一些需要等一会等待换入。</p>
<h2 id="内存换出"><a href="#内存换出" class="headerlink" title="内存换出"></a>内存换出</h2><p>但是我们知道内存总是有限的，不可能总是开辟新的页，有时还需要将一个不怎么使用的页换出，用来给需要使用的页腾出空间，这就涉及到了内存换出。</p>
<p>页面置换有如下几种算法：</p>
<ol>
<li>最优页面置换算法<br>选择当前所有页中最后被用到的页换出，但是操作系统不可能事先知道那些页在什么时候被用到，所以是不可能实现的</li>
<li>NRU算法<br>每个页维护R&#x2F;W位，R位在每次时钟周期置为0，换页时随机选择一个RW位编号最小的页面</li>
<li>FIFO算法<br>先放入的先换出，可能会换出重要页面</li>
<li>第二次机会算法<br>FIFO的变种，每个页维护一个R位，如果R位被设置就放在页链表的末尾然后置为空，再检查下一个页。如果页R位没有被设置就换出</li>
<li>时钟算法<br>第二次机会算法的改进，页链表变成了一个环，如果R被设置就置空然后指向下一个页（还有一种改进的双指针clock算法，前指针和后指针进行扫描，需要设置扫描窗口和扫描时间作为参数，快指针将页R位置为0，然后慢指针还是扫到0，说明在一段时间内没被访问，可以置换）</li>
<li>LRU算法<br>维护页链表，将最近最多使用的放在前面，最近最少使用的放在后面，但是每次访问内存就要更新链表，很耗费时间，如果有硬件支持会很好</li>
<li>NFU算法<br>每个页维护一个计数器，每次访问内存就将所有页的R位加到计数器上，每次选择计数器最小的页换出</li>
<li>老化算法<br>NFU的改良，每个R位都有自己的权重，越久远的R位权重越低（比如可以每次右移然后将R位放到最高位）</li>
<li>工作集算法<br>根据局部性原理，进程在运行的某个时间只会访问某一部分内存，这部分内存就是它的工作集。<br>如果为一个进程分配的页数不足以容纳它的工作集，就会每执行一小段时间就发生缺页中断，叫做<strong>颠簸</strong><br>（工作集同样还需要一个计算算法，一种是通过缺页率计算（PFF），一种是根据时间计算）工作集算法思路就是每次都换出一个不在工作集中的页，这就需要每个进程维护一个工作集，而这又需要使用一些求工作集的算法，总体开销较大，一种比较好的拟合办法就是设置一个工作集时间t，在t以内使用过的内存就是它的工作集，如果当前时间减去每个页维护的上次使用时间大于t，就说明他不在工作集内。</li>
<li>工作集时钟算法<br>与时钟算法相似，如果W没有被设置并且生存时间大于t（工作集时间），就说明这个页面是干净的并且不在工作集，就可以换出，否则就检查下一个页。<br>当指针轮转一圈后，如果至少调度了一次写操作，就去调用那个干净的页。如果没有调用写操作，就随机置换一个干净的页，如果不存在干净的页，就将当前页写回磁盘。</li>
</ol>
<p>总结：</p>
<p><img src="/../image/memory_management/1688350340706.png" alt="1688350340706"></p>
<p>总之，最好的算法是老化算法和工作集时钟算法，它们分别给予LRU和工作集。它们都有良好的页面调度能力和比较容易的实现。在实际应用中，这两种算法是重要的。</p>
<p>为了使分页系统工作良好，仅选择算法是不够的，还要关注很多问题，比如工作集的确定，内存分配算法以及所需的页面大小等。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存</tag>
        <tag>内存管理</tag>
        <tag>虚拟内存</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP基础</title>
    <url>/2023/07/16/tcpip_basics/</url>
    <content><![CDATA[<h1 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h1><p><img src="/image/tcpip_basics/1689512210307.png" alt="1689512210307"></p>
<p>其中左图是ISO OSI七层网络模型，右图是TCP&#x2F;IP四层网络模型</p>
<p>传输层使用的是端到端，网络层是点到点</p>
<p>人们想要使用网络需要ISP提供网络服务</p>
<p>网络通信的方式有电路交换和分组交换，电路交换的话只需要有一条线路就可以一直通信，为了减少上网的门槛，人们提出了分组交换</p>
<p>分组交换就是将要发送的数据分割成一个个的数据包，然后将这些数据包按一定顺序逐个发送到目标地址，实现了从而提高了能够同时上网的人数</p>
<p><img src="/image/tcpip_basics/1689520133360.png" alt="1689520133360"></p>
<p>上图就是一般来说一个数据包的结构，每经过一层都会额外包含一个首部，用来描述本层使用的发送端和接收端的地址，以及上层服务使用的协议，最后在报文的尾部安插一个校验端，用来判断文件是否损坏</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>计算机网络</tag>
        <tag>web</tag>
        <tag>tcp</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器与内存</title>
    <url>/2023/05/11/register_and_memory/</url>
    <content><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h2><p>在了解寄存器之前，我们要了解数据是如何存储的<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683771275654.png" alt="锁存器"><br>我们通过几个逻辑门的组合实现了一个锁存器，上面的输入线叫做输入，下面的输入先叫做复位线，当输入1时，and门总是输出1，这样我们就成功的存储了一位bit，知道我们输入复位，将and门的输入清空</p>
<h2 id="门锁"><a href="#门锁" class="headerlink" title="门锁"></a>门锁</h2><p>但是这样通过锁存器存储还是太麻烦了，我们希望可以有一条线用于输入，一条线用于启动内存，于是设计出了门锁：<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683771522942.png" alt="门锁"></p>
<p>多个门锁排列在一起，就组成了寄存器<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683771783576.png" alt="寄存器"></p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772174357.png" alt="内存中的锁存"><br>内存就是由无数个锁存组成的，我们可以将锁存排列成一个矩阵，然后通过控制行和列来找到特定锁存并激活它<br>因为我们每次只激活一个锁存，所以我们可以只用一根数据线、一根允许写入和一根允许读取，因为当锁存没有被激活时，它会忽略所有的信息</p>
<h2 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h2><p>想要通过这种结构存储大量数据，就需要用到多路复用器，一个多路复用器控制行，一个多路复用器控制列，我们就可以轻松找到矩阵中的某一个锁存，可以读写它的值<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772049711.png" alt="多路复用器"></p>
<h2 id="内存单元"><a href="#内存单元" class="headerlink" title="内存单元"></a>内存单元</h2><p>我们对上面的模型进行简单的抽象，一个256位的内存可以由8条地址线来确定一个特定的锁存，一条数据线用于读和写，一条写入，一条读取线，如图：</p>
<p><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772090587.png" alt="256位内存单元"></p>
<h2 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h2><p>将多个这样的内存单元并排，我们就可以得到一个内存，地址线传入一个地址，然后每个单元都找到自己对应的锁存，将其从自己的数据线传出，就得到了一个数据</p>
<p><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772618137.png" alt="内存"></p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>对上面的物理内存进行抽象，就得到了可以通过一个地址直接寻址的虚拟内存：<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772785273.png" alt="虚拟内存"></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>计算机组成</tag>
        <tag>内存</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么使用要右值引用</title>
    <url>/2023/05/29/rvalue_reference/</url>
    <content><![CDATA[<h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><p>需要搞明白右值引用，必须先明白左值和右值的定义。</p>
<p>所谓左值大致可以理解为有名字，可以取地址，位于赋值符号左侧的值</p>
<p>相反，右值一般没有名字，不可以取地址，位于赋值符号右侧，一般是一些临时变量。</p>
<h1 id="为什么要引用右值引用"><a href="#为什么要引用右值引用" class="headerlink" title="为什么要引用右值引用"></a>为什么要引用右值引用</h1><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>如果使用你使用一个指针指向一个动态开辟的空间的类，并且这个类实现了深拷贝，那么在进行传参的时候就会进行额外的拷贝开销，降低性能。<br>所以我们可以使用const reference技术解决上面这个问题，但是这样同样也带来了另一个问题。</p>
<p>首先const reference可以绑定到任何东西上面，有时候这会带来意想不到的问题，例如不经意间将一个变量隐式类型转换为了一个临时变量，然后reference绑定到了这个临时变量上面，这个临时变量的值有时候不是我们所期望的。</p>
<p>其次，const reference无法修改绑定到的变量上面，如果我们希望将一个string移动到一个vector中（类似所有权的转移），此时如果使用const reference，就需要重新构造一个string，然后将原来的string进行析构，降低了效率（被rust所有权薄纱），所以我们引入了移动语义（使用右值引用），其用法与所有权类似。将这个string的所有权转给vector，只需要简单的修改指针即可，效率大大提高。</p>
<p>引入右值引用后，我们可以使用移动语义将右值引用绑定到一个临时对象，然后可以将其资源（例如堆内存、文件句柄等）有效地转移到新对象中，而无需进行资源拷贝。这通过使用移动构造函数和移动赋值运算符来实现。</p>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>所谓完美转发，就是在函数之间传递参数时总是可以保证参数的类型，例如&amp;&amp;多次转发之后还是&amp;&amp;，&amp;多次转发后还是&amp;</p>
<p>对于const引用，它可以接受任何类型的参数，包括左值和右值。但在转发参数时，它无法保留参数的值类别信息，无法实现完美转发。<br>考虑下面这些函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">overloadedFunction</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;left value ref\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">overloadedFunction</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;right value ref\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">caller</span><span class="params">(T&amp;&amp;a)</span></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;std::is_rvalue_reference_v&lt;<span class="keyword">decltype</span>(a)&gt;&lt;&lt;std::endl;</span><br><span class="line">	<span class="built_in">overloadedFunction</span>(std::forward&lt;T&gt;(a));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">caller</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">caller</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>1<br>right value ref<br>0<br>left value ref</p>
</blockquote>
<p>根据<strong>引用坍缩</strong>，模板参数中的T&amp;&amp;不一定是右值引用，当传入左值时，此函数的引用会被推导为左值。<br>也就是当只有形参实参都为r-ref的时候，才会调用传递之后才是r-ref。</p>
<p>对于右值引用，它可以接受临时对象（右值），并且在转发参数时可以保留参数的值类别信息，可以实现完美转发。右值引用在模板编程中非常有用，可以保留传递参数的值类别，避免不必要的拷贝或移动操作。</p>
<p>在此处我们使用的 <code>std::forward()</code>可以避免额外的拷贝和移动，还可以保持参数的constness，从而达成完美转发</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>与http协作的web服务器</title>
    <url>/2023/07/14/web_server_with_http/</url>
    <content><![CDATA[<h1 id="单台服务器实现多个域名"><a href="#单台服务器实现多个域名" class="headerlink" title="单台服务器实现多个域名"></a>单台服务器实现多个域名</h1><p>事实上，一个服务器可以架设多个网站域名，当使用访问这台服务器上的不同网站时，DNS都会将这些域名解析成同一个IP地址，所以布置需要指定域名，还需要在http请求时，在host首部完整指定主机名或者域名的url</p>
<h1 id="数据转发程序"><a href="#数据转发程序" class="headerlink" title="数据转发程序"></a>数据转发程序</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理服务器会原样地转发客户端的请求</p>
<p>但是会在报文中添加一个via字段指明通过了代理</p>
<p>使用代理的理由：利用缓存技术减少网络带宽、组织内部针对特定网站的访问控制、以获取访问日志为主要目的等</p>
<p>代理有多种使用方法：</p>
<h3 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h3><p>缓存代理会将刚刚用户请求的资源暂时缓存到代理服务器上，当用户多次访问同一个资源的时候可以直接通过代理服务器获取而不用再次访问资源服务器</p>
<p>当资源服务器上的资源更新的时候，代理服务器当然也需要进行资源更新，需要再次访问资源服务器</p>
<h3 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h3><p>转发请求或者响应时，不对报文做任何加工的代理叫做透明代理，反之，对报文有过加工的代理叫做不透明代理</p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关的工作机制与代理代理相似。但是网关能够为通信线路上的服务器提供非http服务，此外，网管也可以提高通信的安全性，可以在客户端与网关之间的通信线路上进行加密</p>
<h2 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h2><p>隧道可按要求建立起一条与其他类型服务器的通信线路，使用ssl等加密手段进行通信</p>
<p>隧道不会解析http请求，只是无情的转发机器</p>
<h1 id="资源缓存"><a href="#资源缓存" class="headerlink" title="资源缓存"></a>资源缓存</h1><p>我们知道，缓存代理可以提供资源缓存服务。其实浏览器本身也可以提供资源缓存服务，这些缓存下来的文件叫做网络临时文件</p>
<p>通过缓存服务器与本地浏览器提供的缓存服务，我们可以减少对资源服务器的访问，从而减少了通信流量和通信时间</p>
<p>但是，为了维护缓存的有效性，必须在资源更新的时候去访问资源服务器更新缓存。</p>
<h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>有两种方法可以确保缓存的有效性，一种是设置一个过期时间</p>
<p>每当过期时间结束的时候，缓存服务器就去资源服务器查看是否有新的资源可用</p>
<h2 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h2><p>还有一种方法就是Entity Tag，每当缓存服务器有访问请求时，就去与资源服务器为这个资源分配的唯一Etag是否一致，如果不一致就需要更新缓存</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>计算机网络</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>SGI STL解析</title>
    <url>/2023/07/16/stl_learning/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
</search>
