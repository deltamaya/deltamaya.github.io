<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IEEE标准的浮点数表示</title>
    <url>/2023/03/27/IEEE%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="结构介绍"><a href="#结构介绍" class="headerlink" title="结构介绍"></a>结构介绍</h1><p>因为计算机中只能离散的保存数据，那么数据的最小位就决定了数据精度。<br>例如： </p>
<ul>
<li>表示整数(int)类型时，最小位是2^0&#x3D;1,因此精度就是1，int类型无法保存任何模1不等于0的数。</li>
</ul>
<p>而小数却不存在最小位（无穷小），因此IEEE协会制定了一种用于表示浮点数的存储方式。<br>已知：</p>
<blockquote>
<p>任何十进制的数都可以表示为n&#x3D;(-1)^s*M*10^E的形式</p>
</blockquote>
<p>其中s是符号位,n为负数时s为0，n为正数时s为1，m是一个尾数，位于1~10之间，e是幂次。例如：12345&#x3D;(-1)^0*1.2345*10^4.</p>
<p>同理：</p>
<blockquote>
<p>任何二进制数都可以表示为n&#x3D;(-1)^s*M*2^E的形式</p>
</blockquote>
<p>符号含义：</p>
<ul>
<li>s:符号(sign)</li>
<li>M:尾数(significand)</li>
<li>E:阶码(exponet)</li>
<li>同时，我们用m代表M中存储的值，e表示E中存储的值。</li>
</ul>
<p>所以，如果我们要存储2进制浮点数，只需要存储s、M、E的值即可。<br>由上述公式可知，m位于1~2之间，因此其最高位总是为1，我们将其省略。<br><br>此外，为了存储e为负数的浮点数，对于E有k位的浮点数，还存在一个<strong>偏置 Bias &#x3D; 2^k-1</strong>,E最终的值要加上偏置后再进行存储。至于为什么不使用负号来表示E，我们之后再展示。<br><br>以32位float为例：</p>
<p><img src="/../img/floatStructure.png" alt="float的具体结构"><br>这样，我们就有了表示浮点数的方法。</p>
<h1 id="值的表示"><a href="#值的表示" class="headerlink" title="值的表示"></a>值的表示</h1><p>这种表示浮点数的方式有三种情况：</p>
<ul>
<li><strong>规格化的值</strong><br>E中的位不全为0，也不全为1。<br>此时n可以由(-1)^s*(1+m)*2^(e-Bias)计算得出。</li>
<li><strong>非规格化的值</strong><br>因为我们假定M始终大于1，所以我们无法表示0.<br>而当<strong>阶码E全为0</strong>时，浮点数表示非规格化的值，它为我们提供了表示0的方法，此时<strong>e&#x3D;1-Bias</strong>。<br>例如：<br>0 00000000 0000000… 表示+0.0<br>1 00000000 0000000… 表示-0.0<br>根据IEEE的浮点格式，+0与-0在某些方面是不同的，而在其他方面是相同的。<br>非规格化数的另一种功能是表示非常接近于0的值。</li>
<li><strong>特殊值</strong><br>最后一类数值是当<strong>阶码E全为1</strong>是出现的。<br>当小数域全为0时，表示<strong>无穷</strong><br>当小数域不为0时，表示<strong>NaN</strong>（不是一个数）<br>例如当两个非常大的数相乘，或者除以0时，会产生无穷。<br>当一些运算不能是实数或者无穷时，返回NaN</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>信息的表示与处理</tag>
        <tag>浮点数</tag>
        <tag>浮点</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2023/03/28/%E5%A0%86md/</url>
    <content><![CDATA[<h1 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h1><p>堆又称<strong>优先队列</strong>，其本质上就是一颗<strong>完全二叉树</strong>，并使用数组的方法实现。堆又分为<strong>大根堆与小根堆</strong>，大根堆就是对于每个节点，它的值比左孩子的值和右孩子的值都大，小根堆即对于每个节点，它的值比左孩子和右孩子的值都小。</p>
<p>以大根堆为例，堆的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;heap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> sz;</span><br><span class="line">	<span class="built_in">Heap</span>():<span class="built_in">heap</span>(),<span class="built_in">sz</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="堆的性质（大根堆）"><a href="#堆的性质（大根堆）" class="headerlink" title="堆的性质（大根堆）"></a>堆的性质（大根堆）</h1><p>大根堆的性质就是对于每个节点，它的值比左孩子的值和右孩子的值都大。<br>为了维护这个性质，在每次插入和删除元素之后我们都要调整堆的结构。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入调整方式如图所示：<br><img src="/../img/heapPush.png" alt="堆插入"></p>
<p><br>当子节点还存在父节点时，若子节点大于父节点，则调换两者位置，然后更新父节点与子节点的位置，知道条件不成立或者子节点没有父节点。<br>具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	heap.<span class="built_in">push_back</span> (x);</span><br><span class="line"><span class="comment">//每个节点的父节点都可以由(n-1)/2求得</span></span><br><span class="line"><span class="comment">//向上调整</span></span><br><span class="line">	<span class="type">int</span> child=sz,father=(sz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&amp;&amp;heap[child]&gt;heap[father])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(heap[child],heap[father]);</span><br><span class="line">		child=father;</span><br><span class="line">		father=(father<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	++sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除时，我们需要注意需要把最后一个元素与堆顶元素进行交换，然后将堆顶元素向下调整。<br><img src="/../img/heapPop.png" alt="堆弹出"><br>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=heap[<span class="number">0</span>];</span><br><span class="line">	--sz;</span><br><span class="line">	<span class="built_in">swap</span>(heap[<span class="number">0</span>],heap[sz]);</span><br><span class="line"><span class="comment">//向下调整</span></span><br><span class="line">	<span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="comment">//选出子节点的最大值</span></span><br><span class="line">		<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;heap[child+<span class="number">1</span>]&gt;heap[child]) &#123;</span><br><span class="line">			++child;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(heap[child]&gt;heap[father])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(heap[child],heap[father]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		father=child;</span><br><span class="line">		child=child*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><p>堆的性质可以帮助我们选出一组数据中<strong>权最大的那个元素</strong>（在这个例子中是数值最大的元素），因此我们可以使用其性质进行排序。</p>
<h2 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="comment">//向上调整建堆</span></span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;++i)&#123;</span><br><span class="line">		<span class="type">int</span> child=i,father=(child<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&amp;&amp;v[child]&gt;v[father])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			child=father;</span><br><span class="line">			father=(father<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始排序</span></span><br><span class="line">	<span class="keyword">while</span>(--sz)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line">		<span class="type">int</span> child=<span class="number">1</span>,father=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>最容易想到的方法是对一个数组向上调整建堆，就像逐个插入一样，但是这样做的时间复杂度是<strong>O(nlogn)<strong>，其实我们有更快的方法，那就是</strong>向下调整建堆</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="comment">//向下调整建堆</span></span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> tmp=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;tmp&gt;<span class="number">0</span>;--tmp)&#123;</span><br><span class="line">		<span class="type">int</span> father=tmp,child=father*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始排序</span></span><br><span class="line">	<span class="keyword">while</span>(--sz)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line">		<span class="type">int</span> child=<span class="number">1</span>,father=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>我们可以从数学角度证明，向下调整建堆的时间复杂度是O(n)，优于向上建堆。<br>数学证明如下：<br><img src="/../img/upAdjustMath.png" alt="向上调整建堆"></p>
<p><img src="/../img/downAdjustMath.png" alt="向下调整建堆"></p>
<p>此外，我们要注意，建堆并不是排序的过程，因此升序需要建大堆，降序要建小堆</p>
<h2 id="TopK："><a href="#TopK：" class="headerlink" title="TopK："></a>TopK：</h2><p>由于二叉堆的性质，我们可以不断的选出一组数据中权最大数，这就是TopK问题：<br>例如：<br>我们可以通过小根堆选出100000个数中最大10个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topK</span><span class="params">(ifstream&amp; fin,<span class="type">const</span> <span class="type">int</span>&amp; K)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(K);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;++i)&#123;</span><br><span class="line">		fin&gt;&gt;ret[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向下调整建堆(小根堆）</span></span><br><span class="line">	<span class="type">int</span> sz=K;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> tmp=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;tmp&gt;<span class="number">0</span>;--tmp)&#123;</span><br><span class="line">		<span class="type">int</span> father=tmp,child=father*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;ret[child+<span class="number">1</span>]&lt;ret[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ret[child]&lt;ret[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(ret[child],ret[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	<span class="keyword">while</span>(fin&gt;&gt;tmp)&#123;</span><br><span class="line">		<span class="comment">//比堆顶大就入堆</span></span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;ret[<span class="number">0</span>])&#123;</span><br><span class="line">			ret[<span class="number">0</span>]=tmp;</span><br><span class="line">			<span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//向下调整</span></span><br><span class="line">			<span class="keyword">while</span>(child&lt;K)&#123;</span><br><span class="line">				<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;ret[child+<span class="number">1</span>]&lt;ret[child])&#123;</span><br><span class="line">					++child;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(ret[child]&lt;ret[father])&#123;</span><br><span class="line">					<span class="built_in">swap</span>(ret[child],ret[father]);</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">				father=child;</span><br><span class="line">				child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，与堆排序不同，<strong>topK要把目标权最小的元素放在堆顶</strong>，例如这里要选出最大的，就要把目前所遇到的最小的元素放在堆顶，使用小根堆</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>堆</tag>
      </tags>
  </entry>
</search>
