<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IEEE754标准的浮点数表示</title>
    <url>/2023/03/27/IEEE%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="结构介绍"><a href="#结构介绍" class="headerlink" title="结构介绍"></a>结构介绍</h1><p>因为计算机中只能离散的保存数据，那么数据的最小位就决定了数据精度。<br>例如：</p>
<ul>
<li>表示整数(int)类型时，最小位是2^0&#x3D;1,因此精度就是1，int类型无法保存任何模1不等于0的数。</li>
</ul>
<p>而小数却不存在最小位（无穷小），因此IEEE协会制定了一种用于表示浮点数的存储方式。<br>已知：</p>
<blockquote>
<p>任何十进制的数都可以表示为$n&#x3D;(-1)^s<em>M</em>10^E$的形式</p>
</blockquote>
<p>其中s是符号位,n为负数时s为0，n为正数时s为1，m是一个尾数，位于1~10之间，e是幂次。例如：$12345&#x3D;(-1)^0<em>1.2345</em>10^4$.</p>
<p>同理：</p>
<blockquote>
<p>任何二进制数都可以表示为$n&#x3D;(-1)^s<em>M</em>2^E$的形式</p>
</blockquote>
<p>符号含义：</p>
<ul>
<li>s:符号(sign)</li>
<li>M:尾数(significand)</li>
<li>E:阶码(exponet)</li>
<li>同时，我们用m代表M中存储的值，e表示E中存储的值。</li>
</ul>
<p>所以，如果我们要存储2进制浮点数，只需要存储s、M、E的值即可。<br>由上述公式可知，m位于1~2之间，因此其最高位总是为1，我们将其省略。</p>
<p>此外，为了存储e为负数的浮点数，对于E有k位的浮点数，还存在一个<strong>偏置</strong> $Bias &#x3D; 2^{k-1}$,E最终的值要加上偏置后再进行存储。</p>
<p>以32位float为例：</p>
<p><img src="/../img/floatStructure.png" alt="float的具体结构"><br>这样，我们就有了表示浮点数的方法。</p>
<h1 id="值的表示"><a href="#值的表示" class="headerlink" title="值的表示"></a>值的表示</h1><p>这种表示浮点数的方式有三种情况：</p>
<ul>
<li><p><strong>规格化的值</strong><br>E中的位不全为0，也不全为1。<br>此时n可以由$(-1)^s*(1+m)*2^{e-Bias}$计算得出。</p>
</li>
<li><p><strong>非规格化的值</strong><br>因为我们假定M始终大于1，所以我们无法表示0.<br>而当<strong>阶码E全为0</strong>时，浮点数表示非规格化的值，它为我们提供了表示0的方法，此时<strong>阶数&#x3D;1-Bias</strong>。<br>例如：<br>0 00000000 0000000… 表示+0.0<br>1 00000000 0000000… 表示-0.0<br>根据IEEE的浮点格式，+0与-0在某些方面是不同的，而在其他方面是相同的。<br>非规格化数的另一种功能是表示非常接近于0的值。</p>
</li>
<li><p><strong>特殊值</strong><br>最后一类数值是当<strong>阶码E全为1</strong>是出现的。</p>
<p>当小数域全为0时，表示<strong>无穷</strong><br>当小数域不为0时，表示<strong>NaN</strong>（Not a Number）</p>
<p>例如当两个非常大的数相乘，或者除以0时，会产生无穷。<br>当一些运算不能是实数或者无穷时，例如无穷加无穷：返回NaN</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>信息的表示与处理</tag>
        <tag>浮点数</tag>
        <tag>浮点</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序算法</title>
    <url>/2023/04/11/Sorts/</url>
    <content><![CDATA[<h1 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h1><hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>十分经典的排序算法，其思想就是依次比较相邻的几个元素，如果逆序就进行交换，如此一趟排序就可以将最大的一个数放到最后，或者将最小的一个数放到最前，就像冒泡一样，因此得名冒泡排序。<br>算法实现（优化版）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;sz;++i)&#123;</span><br><span class="line"><span class="comment">//ok用来记录是否已经有序，为真就提前结束算法</span></span><br><span class="line">		<span class="type">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sz-i;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[j<span class="number">-1</span>]&gt;v[j])&#123;<span class="comment">//有等号时没有稳定性</span></span><br><span class="line">				<span class="built_in">swap</span>(v[j<span class="number">-1</span>],v[j]);</span><br><span class="line">				ok=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ok)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>稳定性：稳定<br><em>当for循环的判断为&gt;&#x3D;或者&lt;&#x3D;时不具备稳定性，因为交换了等值数</em></p>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序就像打牌时插牌一样，拿到一个数之后向已经有序的数组插入，只需要不断向前交换直到前面没有数或者前一个数不大于这个数为止。<br>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;v.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="type">int</span> tmp=i;</span><br><span class="line"><span class="comment">//当有等号时不具备稳定性</span></span><br><span class="line">		<span class="keyword">while</span>(tmp<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;v[tmp<span class="number">-1</span>]&gt;v[tmp])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[tmp<span class="number">-1</span>],v[tmp]);</span><br><span class="line">			--tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(N^2)<br><em>需要注意，插入排序在排序基本有序的数据时有独特的优势，最好可以达到O(N),在排序完全逆序数时是最坏情况，为O(N^2)</em><br>空间复杂度：O(1)<br>稳定性：稳定<br><em>与冒泡排序同理，若交换等值数不具备稳定性</em></p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>十分朴素的一种排序算法，通过对数据进行一次完整遍历来选择出最值，然后将其放到最左或者最右。<br>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> left=<span class="number">0</span>,right=v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="type">int</span> mini=left,maxi=left;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=left;j&lt;=right;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[j]&gt;v[maxi])maxi=j;</span><br><span class="line">			<span class="keyword">if</span>(v[j]&lt;v[mini])mini=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[left],v[mini]);</span><br><span class="line"><span class="comment">//当left与maxi重合时，交换left和mini会使maxi指向最小mini指向最大，所以叫更新mexi的位置</span></span><br><span class="line">		<span class="keyword">if</span>(left==maxi)&#123;</span><br><span class="line">			maxi=mini;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[right],v[maxi]);</span><br><span class="line">		++left;--right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>稳定性：<strong>不稳定</strong><br><em>这里需要格外注意，很多人认为选择排序选最值的方法是稳定的，但是当面对特殊情况下会不稳定，例如：【2，2，1，1】，当选择出最小值时与最左边的值交换，这样就破坏了数据2内的稳定性</em></p>
<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序的核心思想与插入排序一致，但是希尔排序会先对数组进行预排序，使之基本有序，当进行最后一趟排序（也就是插入排序时）会变得很快。<br>预排序时，先每个几个元素进行预插入排序，这样可以使大数很快的跳到后部，小数很快的跳的前部，提高了效率。<br>算法实现；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> gap=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span>(gap&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		gap=gap/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">//也可以选择/2，只要最后一趟是1即可</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;v.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			<span class="type">int</span> tmp=i;</span><br><span class="line">			<span class="keyword">while</span>(tmp-gap&gt;=<span class="number">0</span>&amp;&amp;v[tmp-gap]&gt;v[tmp])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[tmp-gap],v[tmp]);</span><br><span class="line">				tmp-=gap;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：希尔排序的时间复杂度很难进行分析，目前一般认为是O(N^(1.3))左右<br>空间复杂度：O(1)<br>稳定性：不稳定<br><em>虽然插入排序是稳定的，但是希尔排序因为进行了分组，使得同一个数在一组里面可能跳到前面也可能跳到后面，破坏了稳定性</em></p>
<hr>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序利用了二叉堆这种数据结构的性质，它可以轻松的选出一组数里权最大的元素，我们只需要建堆，然后不断将堆顶元素放到数据末端即可。<br>算法实现（详见：<a href="https://deltamaya.top/2023/03/28/%E5%A0%86md/">堆</a>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//向下调整建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">		<span class="type">int</span> father=i,child=(i*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//将堆顶元素与末尾元素交换，然后将堆顶元素向下调整即可</span></span><br><span class="line">	<span class="keyword">while</span>(sz--)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line">		<span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(NlogN)<br>空间复杂度：O(1)<br>稳定性：不稳定</p>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想就是每一趟选定一个数作为key，在一趟排序中将所有比key小的数放到k前面，比k大的数放到k后面，经过一趟这样的排序key就能在最终应该在的位置。<br>选key可以使用随机k法和三数取中法，可以使快排的最坏情况更难出现。<br>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归+双指针法+三数取中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span> (&#123;<span class="number">0</span>,v.<span class="built_in">size</span>()<span class="number">-1</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> left=q.<span class="built_in">front</span>().first,right=q.<span class="built_in">front</span>().second;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> k= <span class="built_in">find_mid</span> (left,right,(left+right)/<span class="number">2</span>,v);</span><br><span class="line">		<span class="built_in">swap</span>(v[k],v[left]);</span><br><span class="line">		k=left;</span><br><span class="line">		<span class="type">int</span> less,cur;</span><br><span class="line">		less=cur=left;</span><br><span class="line">		++cur;</span><br><span class="line">		<span class="keyword">while</span>(cur&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[cur]&lt;v[k]&amp;&amp;++less!=cur)&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[less],v[cur]);</span><br><span class="line">			&#125;</span><br><span class="line">			++cur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[less],v[k]);</span><br><span class="line">		<span class="keyword">if</span>(left&lt;less<span class="number">-1</span>)q.<span class="built_in">push</span> (&#123;left,less<span class="number">-1</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(right&gt;less+<span class="number">1</span>)q.<span class="built_in">push</span> (&#123;less+<span class="number">1</span>,right&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是当数据存在多个重复值时会退化到O(N^2)，我们使用三路划分进行解决</span></span><br><span class="line"><span class="comment">//递归+随机取k+三路划分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickRec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=begin,r=end,cur=l+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//**************leetcode上使用三数取中会TLE，建议使用随机取k***************</span></span><br><span class="line">	<span class="built_in">swap</span>(v[begin+<span class="built_in">rand</span>()%(end-begin+<span class="number">1</span>)],v[l]);</span><br><span class="line">	<span class="type">int</span> target=v[l];</span><br><span class="line">	<span class="keyword">while</span>(cur&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[cur]&lt;target)&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[cur],v[l]);</span><br><span class="line">			++cur;++l;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[cur]==target)&#123;</span><br><span class="line">			++cur;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[r],v[cur]);</span><br><span class="line">			--r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(begin&lt;l<span class="number">-1</span>)<span class="built_in">QuickRec</span>(v,begin,l<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(cur&lt;end)<span class="built_in">QuickRec</span>(v,cur,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********注：当左右边界缩小到一定值时可以使用直接插入排序进行优化，gap一般取10左右******************</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(NlogN)<br>空间复杂度：O(logN)<br><em>需要进行递归或者使用数据记录开始和结束位点</em><br>稳定性：不稳定</p>
<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序与快速排序同样采用分治法对数据进行排序，将两组有序的数组进行归并，变成一个有序的更大的数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortRec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v,<span class="type">int</span> begin,<span class="type">int</span> end,vector&lt;<span class="type">int</span>&gt;&amp;tmp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(begin&gt;=end)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">MergeSortRec</span> (v,begin,mid,tmp);</span><br><span class="line">	<span class="built_in">MergeSortRec</span> (v,mid+<span class="number">1</span>,end,tmp);</span><br><span class="line">	<span class="type">int</span> begin1=begin,end1=mid;</span><br><span class="line">	<span class="type">int</span> begin2=mid+<span class="number">1</span>,end2=end;</span><br><span class="line">	<span class="type">int</span> m=begin;</span><br><span class="line">	<span class="keyword">while</span>(begin1&lt;=end1&amp;&amp;begin2&lt;=end2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[begin1]&lt;v[begin2])&#123;</span><br><span class="line">			tmp[m++]=v[begin1++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp[m++]=v[begin2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(begin1&lt;=end1)&#123;</span><br><span class="line">		tmp[m++]=v[begin1++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(begin2&lt;=end2)&#123;</span><br><span class="line">		tmp[m++]=v[begin2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;=end;++i)&#123;</span><br><span class="line">		v[i]=tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> tmp=v;</span><br><span class="line">	<span class="type">int</span> gap=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( gap &lt; v.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>( i &lt; v.<span class="built_in">size</span>() / gap / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> left_begin = i * <span class="number">2</span> * gap, left_end = left_begin + gap - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> right_begin = left_end + <span class="number">1</span>, right_end = right_begin + gap - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> m = left_begin;</span><br><span class="line">			<span class="comment">//进行边界划分</span></span><br><span class="line">			<span class="comment">//如果rb越界，直接跳出循环，只有一组的不需要归并和拷贝</span></span><br><span class="line">			<span class="keyword">if</span>( right_begin &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>( right_end &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">				right_end= v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//用来打印边界debug</span></span><br><span class="line">			<span class="comment">//printf(&quot;[%d,%d][%d,%d] &quot;,left_begin,left_end,right_begin,right_end);</span></span><br><span class="line">			<span class="keyword">while</span> ( left_begin &lt;= left_end &amp;&amp; right_begin &lt;= right_end ) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( v[ left_begin ] &lt; v[ right_begin ] ) &#123;</span><br><span class="line">					tmp[ m++ ] = v[ left_begin++ ];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tmp[ m++ ] = v[ right_begin++ ];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> ( left_begin &lt;= left_end ) &#123;</span><br><span class="line">				tmp[ m++ ] = v[ left_begin++ ];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> ( right_begin &lt;= right_end ) &#123;</span><br><span class="line">				tmp[ m++ ] = v[ right_begin++ ];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t=i*<span class="number">2</span>*gap;t&lt;=right_end;++t)&#123;</span><br><span class="line">				v[t]=tmp[t];</span><br><span class="line">			&#125;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		gap*=<span class="number">2</span>;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(NlogN)<br>空间复杂度：O(N)<br>稳定性：稳定</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../img/sort_summary.png" alt="总结"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2023/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h1><p><img src="/../img/binary_tree_show.jpg" alt="树"></p>
<blockquote>
<p><strong>结点的度</strong>：一个结点含有的子树的个数称为该结点的度； 如上图：A的为6</p>
<p><strong>叶结点或终端结点</strong>：度为0的结点称为叶结点； 如上图：B、C、H、I…等结点为叶结点</p>
<p><strong>非终端结点或分支结点</strong>：度不为0的结点；  如上图：D、E、F、G…等结点为分支结点</p>
<p><strong>双亲结点或父结点</strong>：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点</p>
<p><strong>孩子结点或子结点</strong>：一个结点含有的子树的根结点称为该结点的子结点；  如上图：B是A的孩子结点</p>
<p><strong>兄弟结点</strong>：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点</p>
<p><strong>树的度</strong>：一棵树中，最大的结点的度称为树的度； 如上图：树的度为6</p>
<p><strong>结点的层次</strong>：从根开始定义起，根为第1层，根的子结点为第2层，以此类推； </p>
<p><strong>树的高度或深度</strong>：树中结点的最大层次；  如上图：树的高度为4</p>
<p><strong>堂兄弟结点</strong>：双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点</p>
<p><strong>结点的祖先</strong>：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先</p>
<p><strong>子孙</strong>：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙</p>
<p><strong>森林</strong>：由m（m&gt;0）棵互不相交的树的集合称为森林；  </p>
</blockquote>
<h1 id="二叉树的结构"><a href="#二叉树的结构" class="headerlink" title="二叉树的结构"></a>二叉树的结构</h1><p>一棵二叉树又三个部分组成：</p>
<ul>
<li>根节点</li>
<li>左子树</li>
<li>右子树</li>
</ul>
<p>我们将树的结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode*left;</span><br><span class="line">	TreeNode*right;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>),<span class="built_in">height</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">	<span class="built_in">TreeNode</span>(): <span class="built_in">TreeNode</span> (<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此当我们需要遍历(Traversal)一棵二叉树时，有四种遍历方法：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>遍历顺序：<strong>根节点-&gt;左子树-&gt;右子树</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">Process</span>(root);</span><br><span class="line">	<span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>遍历顺序：<strong>左子树-&gt;根节点-&gt;右子树</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">Process</span>(root);</span><br><span class="line">	<span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>遍历顺序：<strong>左子树-&gt;右子树-&gt;根节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">latOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">latOrder</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">latOrder</span>(root-&gt;right);</span><br><span class="line">	<span class="built_in">Process</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>遍历顺序：<strong>逐层</strong><br>层序遍历相对比较复杂，我们需要用一个队列来记录<strong>所有同层的节点</strong>然后依次遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">layerOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">	queue&lt;TreeNode*&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		TreeNode *f = q.<span class="built_in">front</span> ();</span><br><span class="line">		<span class="keyword">if</span> ( f-&gt;left )q.<span class="built_in">push</span> (f-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> ( f-&gt;right )q.<span class="built_in">push</span> (f-&gt;right);</span><br><span class="line">		<span class="built_in">Process</span> (f);</span><br><span class="line">		q.<span class="built_in">pop</span> ();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>我们不难发现，所谓的 X序遍历 就是根节点在顺序中的位置</em></p>
<p>二叉树本身就是递归的定义的，所以我们可以得知，二叉树算法中最重要的一点就是递归。</p>
<h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是$2^k -1$ ，则它就是满二叉树。</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</p>
<h2 id="一般二叉树"><a href="#一般二叉树" class="headerlink" title="一般二叉树"></a>一般二叉树</h2><p>对于深度为n的一棵二叉树，节点个数在n至2^n-1之间。<br>同理，对于节点个数为n的二叉树，深度在log(n+1)至n之间。</p>
<blockquote>
<ol>
<li>若规定根结点的层数为1，则一棵非空二叉树的<strong>第i层上最多有2^(i-1)</strong> 个结点.</li>
<li>若规定根结点的层数为1，则<strong>深度为h的二叉树的最大结点数是2^h-1</strong>.</li>
<li>对任何一棵二叉树, <strong>如果度为0其叶结点个数为 n_0, 度为2的分支结点个数为 n_2,则有n_0＝n_2＋1</strong></li>
<li>若规定根结点的层数为1，具有<strong>n个结点的满二叉树的深度</strong>，<strong>h&#x3D;log_2(n+1)</strong>.  (ps：log_2(n+1)是log以2为底，n+1为对数)</li>
<li>对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对于序号为i的结点有：<ol>
<li><strong>若i&gt;0，i位置结点的双亲序号：(i-1)&#x2F;2</strong>；i&#x3D;0，i为根结点编号，无双亲结点</li>
<li><strong>若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;&#x3D;n否则无左孩子</strong></li>
<li><strong>若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;&#x3D;n否则无右孩子</strong></li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2023/04/23/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP算法是一种字符串查找算法，他可以返回字串在原始字符串中第一次出现的位置。<br>时间复杂度是 O(M+N) 空间复杂度O(M)</p>
<p>KMP算法核心逻辑：<strong>当字符不匹配时，从与前一个字符对应的最长相同前后缀的长度之后继续进行搜索</strong></p>
<p>前缀：一定包含首字符但不包含尾字符的连续字串<br>后缀：一定包含尾字符但不包含首字符的连续子串</p>
<p>通俗来讲，当你在某一个字符匹配不上的时候，此时前面所有字符组成的字符串中存在某一个前缀和后缀是相同的（ps：这里都是从前到后读，而<strong>不是</strong>前缀从前往后而，后缀从后往前），所以当你从这个后缀的首字符开始匹配时，一定可以完成这个前缀的匹配，所以我们就不用费力再做一遍了，于是我们直接跳转到这个前缀的后一个字符继续匹配。</p>
<p>例如：text&#x3D;”ABAABABCA”  target&#x3D;”ABABC”<br>target最长相同前后缀的长度数组为：00120</p>
<ol>
<li>当搜索到下标为3时，A与B不匹配，此时从与B的前一个字符A匹配的最长相同前后缀的后面继续搜索，与A匹配的最长前后缀为A，长度为1，所以我们保持text中的指针不动，target中的指针移动到下标为1的位置，我们可以保证下标1之前的元素一定就在text指针的前面，因为我们用target的前缀替代了后缀</li>
<li>同理，B与A然不匹配，此时target指针跳转到0位置，继续搜索</li>
<li>然后不断向前匹配，知道target指针结束或者text指针结束</li>
</ol>
<hr>
<p>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">const</span> string&amp; str,<span class="type">const</span> string&amp; target)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;next;</span><br><span class="line">	<span class="comment">//next数组用于存放每个位置对应的最长相同前后缀的长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;target.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(j+len&lt;=i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(target[j]==target[j+len])&#123;</span><br><span class="line">				++cnt;</span><br><span class="line">				++j;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				++len;</span><br><span class="line">				cnt=<span class="number">0</span>;</span><br><span class="line">				j=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		next.<span class="built_in">push_back</span> (cnt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,f=<span class="number">0</span>,begin=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;str.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i]!=target[f])&#123;</span><br><span class="line">			<span class="keyword">if</span>(f)f=next[f<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				++i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(str[i]==target[f])&#123;</span><br><span class="line">			<span class="keyword">if</span>(f==target.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> i-f;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==str.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			++i;++f;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f)f=next[f<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>搜索</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉堆</title>
    <url>/2023/03/28/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    <content><![CDATA[<h1 id="二叉堆的结构"><a href="#二叉堆的结构" class="headerlink" title="二叉堆的结构"></a>二叉堆的结构</h1><p>二叉堆又称<strong>优先队列</strong>，其本质上就是一颗<strong>完全二叉树</strong>，并使用数组表示。<br>堆又分为<strong>大根堆与小根堆</strong>，<br>大根堆就是对于每个节点，它的值比左孩子的值和右孩子的值都大<br>小根堆即对于每个节点，它的值比左孩子和右孩子的值都小</p>
<p>以大根堆为例，堆的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;heap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> sz;</span><br><span class="line">	<span class="built_in">Heap</span>():<span class="built_in">heap</span>(),<span class="built_in">sz</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="堆的性质（大根堆）"><a href="#堆的性质（大根堆）" class="headerlink" title="堆的性质（大根堆）"></a>堆的性质（大根堆）</h1><p>大根堆的性质就是对于每个节点，它的值比左孩子的值和右孩子的值都大。<br>为了维护这个性质，在每次插入和删除元素之后我们都要调整堆的结构。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入调整方式如图所示：<br><img src="/../img/heapPush.png" alt="堆插入"></p>
<p>当子节点还存在父节点时，若子节点大于父节点，则调换两者位置，然后更新父节点与子节点的位置，知道条件不成立或者子节点没有父节点。<br>具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	heap.<span class="built_in">push_back</span> (x);</span><br><span class="line"><span class="comment">//每个节点的父节点都可以由(n-1)/2求得</span></span><br><span class="line"><span class="comment">//向上调整</span></span><br><span class="line">	<span class="type">int</span> child=sz,father=(sz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&amp;&amp;heap[child]&gt;heap[father])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(heap[child],heap[father]);</span><br><span class="line">		child=father;</span><br><span class="line">		father=(father<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	++sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除时，我们需要注意需要把最后一个元素与堆顶元素进行交换，然后将堆顶元素向下调整。<br><img src="/../img/heapPop.png" alt="堆弹出"><br>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=heap[<span class="number">0</span>];</span><br><span class="line">	--sz;</span><br><span class="line">	<span class="built_in">swap</span>(heap[<span class="number">0</span>],heap[sz]);</span><br><span class="line"><span class="comment">//向下调整</span></span><br><span class="line">	<span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="comment">//选出子节点的最大值</span></span><br><span class="line">		<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;heap[child+<span class="number">1</span>]&gt;heap[child]) &#123;</span><br><span class="line">			++child;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(heap[child]&gt;heap[father])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(heap[child],heap[father]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		father=child;</span><br><span class="line">		child=child*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><p>堆的性质可以帮助我们选出一组数据中<strong>权最大的那个元素</strong>（在这个例子中是数值最大的元素），因此我们可以使用其性质进行排序。</p>
<h2 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="comment">//向上调整建堆</span></span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;++i)&#123;</span><br><span class="line">		<span class="type">int</span> child=i,father=(child<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&amp;&amp;v[child]&gt;v[father])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			child=father;</span><br><span class="line">			father=(father<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始排序</span></span><br><span class="line">	<span class="keyword">while</span>(--sz)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line">		<span class="type">int</span> child=<span class="number">1</span>,father=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最容易想到的方法是对一个数组向上调整建堆，就像逐个插入一样，但是这样做的时间复杂度是<strong>O(nlogn)<strong>，其实我们有更快的方法，那就是</strong>向下调整建堆</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="comment">//向下调整建堆</span></span><br><span class="line">	<span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> tmp=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;tmp&gt;<span class="number">0</span>;--tmp)&#123;</span><br><span class="line">		<span class="type">int</span> father=tmp,child=father*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始排序</span></span><br><span class="line">	<span class="keyword">while</span>(--sz)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line">		<span class="type">int</span> child=<span class="number">1</span>,father=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们可以从数学角度证明，向下调整建堆的时间复杂度是O(n)，优于向上建堆。<br>数学证明如下：<br><img src="/../img/upAdjustMath.png" alt="向上调整建堆"></p>
<p><img src="/../img/downAdjustMath.png" alt="向下调整建堆"></p>
<p>此外，我们要注意，建堆并不是排序的过程，因此升序需要建大堆，降序要建小堆</p>
<h2 id="TopK："><a href="#TopK：" class="headerlink" title="TopK："></a>TopK：</h2><p>由于二叉堆的性质，我们可以不断的选出一组数据中权最大数，这就是TopK问题：<br>例如：<br>我们可以通过小根堆选出100000个数中最大10个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topK</span><span class="params">(ifstream&amp; fin,<span class="type">const</span> <span class="type">int</span>&amp; K)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(K);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;++i)&#123;</span><br><span class="line">		fin&gt;&gt;ret[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向下调整建堆(小根堆）</span></span><br><span class="line">	<span class="type">int</span> sz=K;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> tmp=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;tmp&gt;<span class="number">0</span>;--tmp)&#123;</span><br><span class="line">		<span class="type">int</span> father=tmp,child=father*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line">			<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;ret[child+<span class="number">1</span>]&lt;ret[child])&#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ret[child]&lt;ret[father])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(ret[child],ret[father]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			father=child;</span><br><span class="line">			child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	<span class="keyword">while</span>(fin&gt;&gt;tmp)&#123;</span><br><span class="line">		<span class="comment">//比堆顶大就入堆</span></span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;ret[<span class="number">0</span>])&#123;</span><br><span class="line">			ret[<span class="number">0</span>]=tmp;</span><br><span class="line">			<span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//向下调整</span></span><br><span class="line">			<span class="keyword">while</span>(child&lt;K)&#123;</span><br><span class="line">				<span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;ret[child+<span class="number">1</span>]&lt;ret[child])&#123;</span><br><span class="line">					++child;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(ret[child]&lt;ret[father])&#123;</span><br><span class="line">					<span class="built_in">swap</span>(ret[child],ret[father]);</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">				father=child;</span><br><span class="line">				child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，与堆排序不同，<strong>topK要把目标权最小的元素放在堆顶</strong>，例如这里要选出最大的，就要把目前所遇到的最小的元素放在堆顶，使用小根堆</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>布尔逻辑与逻辑门</title>
    <url>/2023/05/10/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/</url>
    <content><![CDATA[<h1 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h1><p>布尔逻辑中存在两个状态：true和false<br>刚好对应每一个bit的两个状态：1和0<br>存在三种运算与(AND)、或(OR)、非(NOT)<br>通过这三种布尔运算，我们就可以在计算机中进行运算</p>
<h1 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h1><p>在计算机中，我们可以通过逻辑门实现这三种布尔运算逻辑：</p>
<h2 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h2><p>对于布尔运算，我们有一种很好用的电子元件叫做<strong>晶体管</strong></p>
<blockquote>
<p>晶体管一般都有三个极，其中一极兼任输入及输出端子，(B)基极不能做输出，(C)集电极不能做输入之外，其余两个极组成输入及输出对。 晶体管之所以有如此多用途在于其信号放大能力，当微细信号加于其中的一对极时便能控制在另一对极较大的信号，这特性叫<a href="https://zh.wikipedia.org/wiki/%E5%A2%9E%E7%9B%8A" title="增益">增益</a>。</p>
<p>–维基百科</p>
</blockquote>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683685214282.png" alt="晶体管实体"><br><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683685326237.png" alt="晶体管电路图"><br>我们可以将顶部的<strong>基极B作为输入</strong>，将底部的<strong>集电极C作为输出</strong>，那么当我们B输入高电平的时候C也会得到高电平，输入低电平的时候C也会得到低电平，这样我们就得到了一个真值表：true-&gt;true  false-&gt;false</p>
<p><em>这看上去没什么意思，因为最基本的原理我们都懂。</em></p>
<h2 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h2><p>但是在这个晶体管的基础上，我们稍加修改就可以实现<strong>NOT非门</strong>：</p>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683685734975.png" alt="非门"><br>依然将B作为输入，但是我们将输出改为上图的模式，C级接地</p>
<p>那么当我们的B输入true的时候，上下导通，将E端的电流接地，导致输出端没有高电平，输出false<br>而当B输入false，地线不导通，直接流向输出端，此时输出false</p>
<h2 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h2><p>将两个晶体管<strong>串联</strong>，我们就得到了<strong>AND与门</strong>：</p>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683686119690.png" alt="与门"></p>
<p>当一个或者没有晶体管的B级接通时，电路无法导通<br>此时满足AND的真值表，构成与门</p>
<h2 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h2><p>由 <em>与门</em> 我们自然可以得知 <em>或门</em> 的结构，<br>将两个晶体管<strong>并联</strong>，可以得到<strong>OR或门</strong>：<br><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683686324190.png" alt="或门"></p>
<p>当两个晶体管其中的一个导通时，输出端也导通<br>此时满足OR的真值表，构成或门</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>由于这几种门在电路中出现十分频繁，所以我们可以将它们简写成如下形式：</p>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683686573047.png" alt="符号"></p>
<p>如图，我们在图纸上画出这些图形的时候，实际的晶体管和电线依然存在，但是我们将他们抽象封装成了一个符号，这可以让我们的图纸更加简介明了</p>
<h2 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h2><p>我们可以根据以上三种门搭建出另一种常见的门，<strong>XOR异或门</strong>：</p>
<p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683686816940.png" alt="异或门"></p>
<p>下面是异或门的布尔逻辑表达式</p>
<blockquote>
<p>A  <em>xor</em>  B &#x3D; ( <em>not</em>( A <em>and</em> B )  <em>and</em>  ( A <em>or</em> B ) )</p>
</blockquote>
<p>也就是说，<em>A异或B</em>  就是 <em>A或B里有一个true 并且 A和B不能都为true</em></p>
<p>我们也可以通过离散数学中的一个公式帮助理解：</p>
<blockquote>
<p>A  <em>xor</em>  B &#x3D; ( A  <em>and</em>  <em>not</em>B )  <em>or</em>  ( <em>not</em>A <em>and</em> B)</p>
</blockquote>
<p>当A与B相同时，or左右两侧值相同两侧一定都为false，得到的值也为false</p>
<p>当A与B不同时，or左右两侧的值至少有一侧为true，输出true</p>
<h1 id="抽象-1"><a href="#抽象-1" class="headerlink" title="抽象"></a>抽象</h1><p><img src="/../img/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/1683687474009.png" alt="基本符号"><br>上面是一些逻辑门的抽象符号</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" title="计算机科学">计算机科学</a>中， <strong>抽象化</strong> （英语：Abstraction）是将资料与程序，以它的语义来呈现出它的外观，但是隐藏起它的实现细节。抽象化是用来减少程序的复杂度，使得程序员可以专注在处理少数重要的部分。一个电脑系统可以分割成几个<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B1%A4" title="抽象层">抽象层</a>（Abstraction layer），使得程序员可以将它们分开处理。</p>
<p>–维基百科</p>
</blockquote>
<p>在这里我们了解到了<strong>抽象</strong>的含义，我们将隐藏复杂组件中具体的实现细节，将精力放到自己要做的事情上。<br>例如：一个程序员不需要了解自己写的程序需要几个晶体管几个逻辑门，也不需要了解电子在电路中是怎么移动的，但是他依然可以写出可以运行的程序，这就是抽象的意义。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>布尔逻辑</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU结构和原理</title>
    <url>/2023/05/10/CPU/</url>
    <content><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>首先我们来看一下什么是CPU：</p>
<blockquote>
<p><strong>中央处理器</strong> （英语：<strong>C</strong>entral <strong>P</strong>rocessing <strong>U</strong>nit，缩写： <strong>CPU</strong> ）是<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA" title="电子计算机">计算机</a>的主要设备之一，功能主要是解释计算机<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4" title="指令">指令</a>以及处理计算机<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" title="软件">软件</a>中的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE" title="数据">数据</a>。</p>
<p>–维基百科</p>
</blockquote>
<h2 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h2><p><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683714535332.png" alt="CPU结构"><br>可以看到，CPU中有若干寄存器、ALU和一个控制单元，大体介绍一下这些组件的功能：</p>
<ul>
<li>寄存器：CPU中用来暂时存储数据、处理数据的小型存储区域</li>
<li>ALU（算数逻辑单元）：用来执行算数或者逻辑操作</li>
<li>控制单元：控制各个组件的运行</li>
</ul>
<h3 id="寄存器、ALU"><a href="#寄存器、ALU" class="headerlink" title="寄存器、ALU"></a>寄存器、ALU</h3><p>关于寄存器和ALU的介绍我单独写了博客，你可以在这里查看：<a href="./ALU.md">ALU</a>、<a href="./%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98.md">寄存器</a></p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器中也有若干寄存器，其中一个叫做<strong>PC(Program Counter)程序计数器</strong>、一个叫做<strong>IR(Instruction Register)指令寄存器</strong>，PC中存储着计算机要执行的<strong>下一条指令的地址</strong>，IR中则存储着计算机<strong>要执行的指令</strong>，它们都被编码为了二进制</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>CPU是计算机用于执行指令的一个组件，指令就是计算机中的一个个操作，例如将一个值拷贝到一个地方、将两个值相加..</p>
<p>因为CPU无法理解自然语言，所以如果要执行指令，我们就要对指令进行编码，为了简化模型，这里我们以8位的长度举例：<br><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683712829076.png" alt="指令编码"><br>这里对四条指令进行了编码，每个指令都有自己的操作码和操作数，<br>在这里一条指令的前四位是<strong>操作码</strong>，后四位是<strong>操作数</strong><br>操作码对应CPU要执行的操作，操作数对应CPU操作的对象<br>在需要执行指令时，CPU将会根据操作码和操作数进行具体的操作。</p>
<blockquote>
<p>计算机的指令需要存储在<strong>内存RAM</strong>中，如果你对此不太了解可以看这篇博客：<a href="./%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98.md">寄存器和内存</a></p>
</blockquote>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>这里先以取数为例</p>
<p><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683715030031.png" alt="取数的执行过程"></p>
<ol>
<li><strong>取指令</strong>：开机之后PC中存储着要执行的指令的地址，PC将这个地址传给MAR，然后内存在这个地址中搜索，将地址中存储的值传给MDR，然后再传回CPU的IR中</li>
<li><strong>解码</strong>：CU控制单元对IR中的指令进行解码，得到操作码对应要执行的操作，得到操作数对应要执行操作的对象</li>
<li><strong>执行</strong>：经过分析，这条指令的内容是从一个地址中取出一个数放到某个寄存器中。那么CPU就会将这个地址传给MAR，然后将取得的数放到寄存器中。</li>
<li>指令执行结束，PC自增1，指向下一条指令</li>
</ol>
<h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>在上面描述的一个周期中，我们需要在状态之间不断切换，那怎样才能知道接下来要做什么呢？<br>答案就是：<strong>时钟</strong></p>
<p>时钟是一个电子元件，以准确的时间间隔触发电信号，<br>这个循环执行一次就叫做一个<strong>时钟周期</strong></p>
<blockquote>
<p>取指令 -&gt; 解码 -&gt; 执行<br><strong>CPU就会根据时钟信号推进上述周期的执行。</strong></p>
</blockquote>
<p>例如，如果一个CPU的频率是5.0 GHz，那么这个CPU就可以每秒操作50亿</p>
<h3 id="超频"><a href="#超频" class="headerlink" title="超频"></a>超频</h3><p><strong>超频</strong>就是通过提高时钟频率来达到<strong>提高CPU性能</strong>的目的，<br>芯片制造商一般会为CPU留一些余地，可以接受一些超频，但是长时间的超频可能会造成过热，或者会产生乱码，因为信号跟不上时钟</p>
<h3 id="降频"><a href="#降频" class="headerlink" title="降频"></a>降频</h3><p>你可能很少听说<strong>降频</strong>，但是降频是一个很好的手段来<strong>降低能耗</strong><br>当你的手机或者其他移动设备没有进行很多计算时，对CPU进行降频减慢CPU的计算速度可以减少能耗，提高续航</p>
<blockquote>
<p>现代的很多处理器都可以根据需求调整时钟频率</p>
</blockquote>
<h1 id="高级CPU设计"><a href="#高级CPU设计" class="headerlink" title="高级CPU设计"></a>高级CPU设计</h1><p>早期对CPU进行优化提速的方法主要是减少晶体管的切换时间，但是这种优化硬件的方法很快就遇到了瓶颈，所以厂商们探索出了更多的设计模式，可以大大提高CPU的运行速度</p>
<h2 id="优化电路"><a href="#优化电路" class="headerlink" title="优化电路"></a>优化电路</h2><p>早期的CPU进行除法时要调用多次减法，这样会花费很多个时钟周期，在操作很大或者很多的数的时候效率十分低下，所以厂商们研发出了直接用于除法的ALU电路，解决了这个问题，提高了运行速度</p>
<p>随着计算机的发展，CPU中也加入了更多可以快速执行原先需要很多时钟周期才能完成的指令的电路</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>很高的主频则会带来另一个问题，CPU从内存读取指令的速度一般需要几个时钟周期，远跟不上CPU执行指令的速度，这会让CPU处于等待状态，效率低下</p>
<p>所以我们在CPU中加入了<strong>Cache缓存</strong>（kB或MB级），在读取指令时CPU可以一次性从内存<strong>读取多条指令暂存到缓存</strong>中，这是很实用的，因为计算机中大多是时候指令都是顺序执行</p>
<p>在CPU执行完一条指令之后可以马上从缓存读取下一条指令而无需等待内存</p>
<p>当想要的内容在缓存中时叫做缓存命中<strong>cache hit</strong><br>不在缓存中则成为缓存未命中<strong>cache miss</strong></p>
<p>缓存也可以存储一些临时值，用于复杂计算</p>
<h3 id="脏位"><a href="#脏位" class="headerlink" title="脏位"></a>脏位</h3><p>当我们计算完一些值需要写到内存中时，我们可以将其<strong>暂存到缓存</strong>，如果后续还要接着算，这么做也会提高效率。</p>
<p>当我们把一个数据存到缓存中，我们把这个缓存中的位置标记为<strong>脏位（Dirty bit）</strong><br><strong>同步</strong>一般会发生在缓存已经写满，但还需要从内存读取数据时<br>同步时CPU会<strong>把脏位中的数据先写到RAM</strong>，然后再从RAM进行读取</p>
<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683719476635.png" alt="非流水线模式"><br>因为取指令、解码、执行分别用的CPU中不同的组件，在非流水线模式下CPU同一时刻只能用到某部分组件，效率低下</p>
<p><img src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/1683719503473.png" alt="流水线模式"><br>流水线模式下同时调动CPU中的全部组件，<a href="https://zh.wikipedia.org/wiki/%E5%90%9E%E5%90%90%E9%87%8F">吞吐量</a>*3</p>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>流水线并行执行下我们要注意指令间的依赖性，在必要的时候停止流水线，防止出现错误<br>在现代处理器中往往会对流水线进行优化，最小化停止时间，这叫做<strong>乱序执行</strong></p>
<h3 id="预测执行"><a href="#预测执行" class="headerlink" title="预测执行"></a>预测执行</h3><p>最后，当程序出现条件控制时，原始的处理器会等待判断结果，然后再根据结果执行，效率低下</p>
<p>现代处理器中，一般采用一些算法来预测程序接下来要执行的程序，这叫做<strong>分支预测</strong></p>
<p>在判断结果出来之前就进行读取。当判断结果出来之后，如果猜测是正确的，那么此时缓存中都是正确的指令，马上就可以执行</p>
<p>如果猜测错误，那么就会<strong>清空流水线</strong>，耗费大量时间</p>
<p>但是不用担心，现代处理器猜测<strong>命中率超过90%</strong></p>
<h2 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h2><p>上面的方法都是优化一个指令流的速度<br>而多核，也就是在CPU中添加多个独立处理单元，来同时执行多个指令流</p>
<h2 id="多CPU"><a href="#多CPU" class="headerlink" title="多CPU"></a>多CPU</h2><p>同样的，一台计算机里多塞几个CPU也能提高效率</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>ALU结构和原理</title>
    <url>/2023/05/11/ALU/</url>
    <content><![CDATA[<h1 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h1><p>先来看看维基百科是怎么说的</p>
<blockquote>
<p><strong>算术逻辑单元</strong> （英语：Arithmetic logic unit，<a href="https://zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB" title="缩写">缩写</a>： <strong>ALU</strong> ）是一种可对<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6" title="二进制">二进制</a><a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0" title="整数">整数</a>执行<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF" title="算术">算术运算</a>或<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C" title="位操作">位运算</a>的<a href="https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF" title="组合逻辑电路">组合逻辑</a><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF" title="数字电路">数字电路</a>。ALU 与<a href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8" title="浮点运算器">浮点数运算单元</a>（FPU）不同，后者仅对<a href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8" title="浮点运算器">浮点数</a>进行操作。ALU 是许多类型的计算电路的基本部件，这些计算电路包括计算机的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8" title="中央处理器">中央处理单元</a>（CPU）、<a href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8" title="浮点运算器">浮点处理单元</a>（FPU）和<a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8" title="图形处理器">图形处理单元</a>（GPU）。单个CPU、FPU 或 GPU 可能包含多个 ALU。</p>
<p>–维基百科</p>
</blockquote>
<p>ALU就是计算机中用来进行算数逻辑运算的核心单元，我们可以用它来进行加减乘除等操作</p>
<h2 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h2><p>为了实现最基本的加法功能，我们可以使用逻辑门搭建一个半加器，在这里：<a href="https://deltamaya.top/2023/05/10/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E4%B8%8E%E9%80%BB%E8%BE%91%E9%97%A8/">逻辑门</a>，我介绍了如何用晶体管搭建逻辑门。</p>
<p>先来看看结构：<br><img src="/../image/ALU/1683766407298.png" alt="半加器"></p>
<p>我们使用异或门对A和B进行运算，但是这样无法判定进位，所以我们又加入了一个与门来判定是否进位<br>其中A和B就是要执行操作的两个bit，sum就是求和之后的低位，carry是进位。</p>
<h2 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h2><p>但是，如果我们需要进行超过1+1的运算，就需要使用全加器<br><img src="/../image/ALU/1683766572913.png" alt="全加器"><br>这里我们就可以对进位也进行运算了，A和B就是要进行运算的两个位，C是低位运算进上来的位，我们可以通过全加器对三个位进行运算，同样输出结果sum和进位carry</p>
<h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><p>万事俱备，这样我们就可以使用半加器和全加器对任意两个二进制数进行运算了，低位使用半加器，后面的每一位使用全加器即可，如图：<br><img src="/../image/ALU/1683767140631.png" alt="加法器"><br>A和B是两个8位的二级制数，后面跟的数字代表是第几位，这里我们注意到，最后一个全加器依然输出了一个carry，如果两个数的运算让这个carry是1，说明这两个数相加太大，超过了8位可以表示的范围，叫做溢出</p>
<blockquote>
<p>尽管每个进位消耗的时间很少，但是在计算机每秒数十亿次的计算中，这种消耗也是很难以接受的，所以现代处理器中一般使用<strong>超前进位加法器</strong>，结构与这里略有不同</p>
</blockquote>
<h2 id="其他运算器"><a href="#其他运算器" class="headerlink" title="其他运算器"></a>其他运算器</h2><p><img src="/../image/ALU/1683767512270.png" alt="其他运算"><br>这是ALU中可以进行的一部分其他操作，就像加法器，它们也是使用一个个逻辑门搭建出来的</p>
<h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><img src="/../image/ALU/1683767778314.png" alt="ALU"><br>可以看到，ALU在接受A和B两个输入进行运算时，还会产生3个标志位，比如overflow会在结果溢出时置为1，zero会在结果为0时置为一<br>高级ALU有更多的标志位，但这三种是最普遍的</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>CPU</tag>
        <tag>ALU</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器与内存</title>
    <url>/2023/05/11/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h2><p>在了解寄存器之前，我们要了解数据是如何存储的<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683771275654.png" alt="锁存器"><br>我们通过几个逻辑门的组合实现了一个锁存器，上面的输入线叫做输入，下面的输入先叫做复位线，当输入1时，and门总是输出1，这样我们就成功的存储了一位bit，知道我们输入复位，将and门的输入清空</p>
<h2 id="门锁"><a href="#门锁" class="headerlink" title="门锁"></a>门锁</h2><p>但是这样通过锁存器存储还是太麻烦了，我们希望可以有一条线用于输入，一条线用于启动内存，于是设计出了门锁：<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683771522942.png" alt="门锁"></p>
<p>多个门锁排列在一起，就组成了寄存器<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683771783576.png" alt="寄存器"></p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772174357.png" alt="内存中的锁存"><br>内存就是由无数个锁存组成的，我们可以将锁存排列成一个矩阵，然后通过控制行和列来找到特定锁存并激活它<br>因为我们每次只激活一个锁存，所以我们可以只用一根数据线、一根允许写入和一根允许读取，因为当锁存没有被激活时，它会忽略所有的信息</p>
<h2 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h2><p>想要通过这种结构存储大量数据，就需要用到多路复用器，一个多路复用器控制行，一个多路复用器控制列，我们就可以轻松找到矩阵中的某一个锁存，可以读写它的值<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772049711.png" alt="多路复用器"></p>
<h2 id="内存单元"><a href="#内存单元" class="headerlink" title="内存单元"></a>内存单元</h2><p>我们对上面的模型进行简单的抽象，一个256位的内存可以由8条地址线来确定一个特定的锁存，一条数据线用于读和写，一条写入，一条读取线，如图：</p>
<p><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772090587.png" alt="256位内存单元"></p>
<h2 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h2><p>将多个这样的内存单元并排，我们就可以得到一个内存，地址线传入一个地址，然后每个单元都找到自己对应的锁存，将其从自己的数据线传出，就得到了一个数据</p>
<p><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772618137.png" alt="内存"></p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>对上面的物理内存进行抽象，就得到了可以通过一个地址直接寻址的虚拟内存：<br><img src="/../image/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/1683772785273.png" alt="虚拟内存"></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>CPU</tag>
        <tag>寄存器</tag>
        <tag>内存</tag>
      </tags>
  </entry>
</search>
