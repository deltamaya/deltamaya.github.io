<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玛雅55369</title>
  
  <subtitle>deltamaya</subtitle>
  <link href="http://www.deltamaya.top/atom.xml" rel="self"/>
  
  <link href="http://www.deltamaya.top/"/>
  <updated>2023-04-23T07:57:52.478Z</updated>
  <id>http://www.deltamaya.top/</id>
  
  <author>
    <name>deltamaya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础排序算法</title>
    <link href="http://www.deltamaya.top/2023/04/11/Sorts/"/>
    <id>http://www.deltamaya.top/2023/04/11/Sorts/</id>
    <published>2023-04-11T07:33:16.451Z</published>
    <updated>2023-04-23T07:57:52.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h1><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>十分经典的排序算法，其思想就是依次比较相邻的几个元素，如果逆序就进行交换，如此一趟排序就可以将最大的一个数放到最后，或者将最小的一个数放到最前，就像冒泡一样，因此得名冒泡排序。<br>算法实现（优化版）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;sz;++i)&#123;</span><br><span class="line"><span class="comment">//ok用来记录是否已经有序，为真就提前结束算法</span></span><br><span class="line"><span class="type">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sz-i;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[j<span class="number">-1</span>]&gt;v[j])&#123;<span class="comment">//有等号时没有稳定性</span></span><br><span class="line"><span class="built_in">swap</span>(v[j<span class="number">-1</span>],v[j]);</span><br><span class="line">ok=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ok)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>稳定性：稳定<br><em>当for循环的判断为&gt;&#x3D;或者&lt;&#x3D;时不具备稳定性，因为交换了等值数</em></p><hr><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序就像打牌时插牌一样，拿到一个数之后向已经有序的数组插入，只需要不断向前交换直到前面没有数或者前一个数不大于这个数为止。<br>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;v.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line"><span class="type">int</span> tmp=i;</span><br><span class="line"><span class="comment">//当有等号时不具备稳定性</span></span><br><span class="line"><span class="keyword">while</span>(tmp<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;v[tmp<span class="number">-1</span>]&gt;v[tmp])&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[tmp<span class="number">-1</span>],v[tmp]);</span><br><span class="line">--tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N^2)<br><em>需要注意，插入排序在排序基本有序的数据时有独特的优势，最好可以达到O(N),在排序完全逆序数时是最坏情况，为O(N^2)</em><br>空间复杂度：O(1)<br>稳定性：稳定<br><em>与冒泡排序同理，若交换等值数不具备稳定性</em></p><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>十分朴素的一种排序算法，通过对数据进行一次完整遍历来选择出最值，然后将其放到最左或者最右。<br>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> left=<span class="number">0</span>,right=v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="type">int</span> mini=left,maxi=left;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=left;j&lt;=right;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[j]&gt;v[maxi])maxi=j;</span><br><span class="line"><span class="keyword">if</span>(v[j]&lt;v[mini])mini=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(v[left],v[mini]);</span><br><span class="line"><span class="comment">//当left与maxi重合时，交换left和mini会使maxi指向最小mini指向最大，所以叫更新mexi的位置</span></span><br><span class="line"><span class="keyword">if</span>(left==maxi)&#123;</span><br><span class="line">maxi=mini;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(v[right],v[maxi]);</span><br><span class="line">++left;--right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(N^2)<br>空间复杂度：O(1)<br>稳定性：<strong>不稳定</strong><br><em>这里需要格外注意，很多人认为选择排序选最值的方法是稳定的，但是当面对特殊情况下会不稳定，例如：【2，2，1，1】，当选择出最小值时与最左边的值交换，这样就破坏了数据2内的稳定性</em></p><hr><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序的核心思想与插入排序一致，但是希尔排序会先对数组进行预排序，使之基本有序，当进行最后一趟排序（也就是插入排序时）会变得很快。<br>预排序时，先每个几个元素进行预插入排序，这样可以使大数很快的跳到后部，小数很快的跳的前部，提高了效率。<br>算法实现；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> gap=v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(gap&gt;<span class="number">1</span>)&#123;</span><br><span class="line">gap=gap/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">//也可以选择/2，只要最后一趟是1即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;v.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line"><span class="type">int</span> tmp=i;</span><br><span class="line"><span class="keyword">while</span>(tmp-gap&gt;=<span class="number">0</span>&amp;&amp;v[tmp-gap]&gt;v[tmp])&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[tmp-gap],v[tmp]);</span><br><span class="line">tmp-=gap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：希尔排序的时间复杂度很难进行分析，目前一般认为是O(N^(1.3))左右<br>空间复杂度：O(1)<br>稳定性：不稳定<br><em>虽然插入排序是稳定的，但是希尔排序因为进行了分组，使得同一个数在一组里面可能跳到前面也可能跳到后面，破坏了稳定性</em></p><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序利用了二叉堆这种数据结构的性质，它可以轻松的选出一组数里权最大的元素，我们只需要建堆，然后不断将堆顶元素放到数据末端即可。<br>算法实现（详见：<a href="https://deltamaya.top/2023/03/28/%E5%A0%86md/">堆</a>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//向下调整建堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="type">int</span> father=i,child=(i*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">father=child;</span><br><span class="line">child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将堆顶元素与末尾元素交换，然后将堆顶元素向下调整即可</span></span><br><span class="line"><span class="keyword">while</span>(sz--)&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line"><span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">father=child;</span><br><span class="line">child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(NlogN)<br>空间复杂度：O(1)<br>稳定性：不稳定</p><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想就是每一趟选定一个数作为key，在一趟排序中将所有比key小的数放到k前面，比k大的数放到k后面，经过一趟这样的排序key就能在最终应该在的位置。<br>选key可以使用随机k法和三数取中法，可以使快排的最坏情况更难出现。<br>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归+双指针法+三数取中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">q.<span class="built_in">push</span> (&#123;<span class="number">0</span>,v.<span class="built_in">size</span>()<span class="number">-1</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> left=q.<span class="built_in">front</span>().first,right=q.<span class="built_in">front</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> k= <span class="built_in">find_mid</span> (left,right,(left+right)/<span class="number">2</span>,v);</span><br><span class="line"><span class="built_in">swap</span>(v[k],v[left]);</span><br><span class="line">k=left;</span><br><span class="line"><span class="type">int</span> less,cur;</span><br><span class="line">less=cur=left;</span><br><span class="line">++cur;</span><br><span class="line"><span class="keyword">while</span>(cur&lt;=right)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[cur]&lt;v[k]&amp;&amp;++less!=cur)&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[less],v[cur]);</span><br><span class="line">&#125;</span><br><span class="line">++cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(v[less],v[k]);</span><br><span class="line"><span class="keyword">if</span>(left&lt;less<span class="number">-1</span>)q.<span class="built_in">push</span> (&#123;left,less<span class="number">-1</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(right&gt;less+<span class="number">1</span>)q.<span class="built_in">push</span> (&#123;less+<span class="number">1</span>,right&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是当数据存在多个重复值时会退化到O(N^2)，我们使用三路划分进行解决</span></span><br><span class="line"><span class="comment">//递归+随机取k+三路划分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickRec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=begin,r=end,cur=l+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//**************leetcode上使用三数取中会TLE，建议使用随机取k***************</span></span><br><span class="line"><span class="built_in">swap</span>(v[begin+<span class="built_in">rand</span>()%(end-begin+<span class="number">1</span>)],v[l]);</span><br><span class="line"><span class="type">int</span> target=v[l];</span><br><span class="line"><span class="keyword">while</span>(cur&lt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[cur]&lt;target)&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[cur],v[l]);</span><br><span class="line">++cur;++l;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[cur]==target)&#123;</span><br><span class="line">++cur;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[r],v[cur]);</span><br><span class="line">--r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(begin&lt;l<span class="number">-1</span>)<span class="built_in">QuickRec</span>(v,begin,l<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(cur&lt;end)<span class="built_in">QuickRec</span>(v,cur,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********注：当左右边界缩小到一定值时可以使用直接插入排序进行优化，gap一般取10左右******************</span></span><br></pre></td></tr></table></figure><p>时间复杂度：O(NlogN)<br>空间复杂度：O(logN)<br><em>需要进行递归或者使用数据记录开始和结束位点</em><br>稳定性：不稳定</p><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序与快速排序同样采用分治法对数据进行排序，将两组有序的数组进行归并，变成一个有序的更大的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortRec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v,<span class="type">int</span> begin,<span class="type">int</span> end,vector&lt;<span class="type">int</span>&gt;&amp;tmp)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(begin&gt;=end)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">MergeSortRec</span> (v,begin,mid,tmp);</span><br><span class="line"><span class="built_in">MergeSortRec</span> (v,mid+<span class="number">1</span>,end,tmp);</span><br><span class="line"><span class="type">int</span> begin1=begin,end1=mid;</span><br><span class="line"><span class="type">int</span> begin2=mid+<span class="number">1</span>,end2=end;</span><br><span class="line"><span class="type">int</span> m=begin;</span><br><span class="line"><span class="keyword">while</span>(begin1&lt;=end1&amp;&amp;begin2&lt;=end2)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[begin1]&lt;v[begin2])&#123;</span><br><span class="line">tmp[m++]=v[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tmp[m++]=v[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(begin1&lt;=end1)&#123;</span><br><span class="line">tmp[m++]=v[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(begin2&lt;=end2)&#123;</span><br><span class="line">tmp[m++]=v[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;=end;++i)&#123;</span><br><span class="line">v[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> tmp=v;</span><br><span class="line"><span class="type">int</span> gap=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( gap &lt; v.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt; v.<span class="built_in">size</span>() / gap / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> left_begin = i * <span class="number">2</span> * gap, left_end = left_begin + gap - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right_begin = left_end + <span class="number">1</span>, right_end = right_begin + gap - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> m = left_begin;</span><br><span class="line"><span class="comment">//进行边界划分</span></span><br><span class="line"><span class="comment">//如果rb越界，直接跳出循环，只有一组的不需要归并和拷贝</span></span><br><span class="line"><span class="keyword">if</span>( right_begin &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( right_end &gt;= v.<span class="built_in">size</span>())&#123;</span><br><span class="line">right_end= v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来打印边界debug</span></span><br><span class="line"><span class="comment">//printf(&quot;[%d,%d][%d,%d] &quot;,left_begin,left_end,right_begin,right_end);</span></span><br><span class="line"><span class="keyword">while</span> ( left_begin &lt;= left_end &amp;&amp; right_begin &lt;= right_end ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( v[ left_begin ] &lt; v[ right_begin ] ) &#123;</span><br><span class="line">tmp[ m++ ] = v[ left_begin++ ];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp[ m++ ] = v[ right_begin++ ];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( left_begin &lt;= left_end ) &#123;</span><br><span class="line">tmp[ m++ ] = v[ left_begin++ ];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( right_begin &lt;= right_end ) &#123;</span><br><span class="line">tmp[ m++ ] = v[ right_begin++ ];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=i*<span class="number">2</span>*gap;t&lt;=right_end;++t)&#123;</span><br><span class="line">v[t]=tmp[t];</span><br><span class="line">&#125;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">gap*=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(NlogN)<br>空间复杂度：O(N)<br>稳定性：稳定</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../img/sort_summary.png" alt="总结"></p>]]></content>
    
    
    <summary type="html">简要介绍几类基础比较排序算法</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://www.deltamaya.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://www.deltamaya.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://www.deltamaya.top/tags/C/"/>
    
    <category term="排序" scheme="http://www.deltamaya.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://www.deltamaya.top/2023/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.deltamaya.top/2023/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-30T09:15:00.178Z</published>
    <updated>2023-04-23T03:24:16.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h1><p><img src="/../img/binary_tree_show.jpg" alt="树"></p><blockquote><p><strong>结点的度</strong>：一个结点含有的子树的个数称为该结点的度； 如上图：A的为6</p><p><strong>叶结点或终端结点</strong>：度为0的结点称为叶结点； 如上图：B、C、H、I…等结点为叶结点</p><p><strong>非终端结点或分支结点</strong>：度不为0的结点；  如上图：D、E、F、G…等结点为分支结点</p><p><strong>双亲结点或父结点</strong>：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点</p><p><strong>孩子结点或子结点</strong>：一个结点含有的子树的根结点称为该结点的子结点；  如上图：B是A的孩子结点</p><p><strong>兄弟结点</strong>：具有相同父结点的结点互称为兄弟结点； 如上图：B、C是兄弟结点</p><p><strong>树的度</strong>：一棵树中，最大的结点的度称为树的度； 如上图：树的度为6</p><p><strong>结点的层次</strong>：从根开始定义起，根为第1层，根的子结点为第2层，以此类推； </p><p><strong>树的高度或深度</strong>：树中结点的最大层次；  如上图：树的高度为4</p><p><strong>堂兄弟结点</strong>：双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点</p><p><strong>结点的祖先</strong>：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先</p><p><strong>子孙</strong>：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙</p><p><strong>森林</strong>：由m（m&gt;0）棵互不相交的树的集合称为森林；  </p></blockquote><h1 id="二叉树的结构"><a href="#二叉树的结构" class="headerlink" title="二叉树的结构"></a>二叉树的结构</h1><p>一棵二叉树又三个部分组成：</p><ul><li>根节点</li><li>左子树</li><li>右子树</li></ul><p>我们将树的结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode*left;</span><br><span class="line">TreeNode*right;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>),<span class="built_in">height</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line"><span class="built_in">TreeNode</span>(): <span class="built_in">TreeNode</span> (<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此当我们需要遍历(Traversal)一棵二叉树时，有四种遍历方法：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ul><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>遍历顺序：<strong>根节点-&gt;左子树-&gt;右子树</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">Process</span>(root);</span><br><span class="line"><span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>遍历顺序：<strong>左子树-&gt;根节点-&gt;右子树</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">Process</span>(root);</span><br><span class="line"><span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>遍历顺序：<strong>左子树-&gt;右子树-&gt;根节点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">latOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">latOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">latOrder</span>(root-&gt;right);</span><br><span class="line"><span class="built_in">Process</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>遍历顺序：<strong>逐层</strong><br>层序遍历相对比较复杂，我们需要用一个队列来记录<strong>所有同层的节点</strong>然后依次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">layerOrder</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">queue&lt;TreeNode*&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">TreeNode *f = q.<span class="built_in">front</span> ();</span><br><span class="line"><span class="keyword">if</span> ( f-&gt;left )q.<span class="built_in">push</span> (f-&gt;left);</span><br><span class="line"><span class="keyword">if</span> ( f-&gt;right )q.<span class="built_in">push</span> (f-&gt;right);</span><br><span class="line"><span class="built_in">Process</span> (f);</span><br><span class="line">q.<span class="built_in">pop</span> ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>我们不难发现，所谓的 X序遍历 就是根节点在顺序中的位置</em></p><p>二叉树本身就是递归的定义的，所以我们可以得知，二叉树算法中最重要的一点就是递归。</p><h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是$2^k -1$ ，则它就是满二叉树。</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</p><h2 id="一般二叉树"><a href="#一般二叉树" class="headerlink" title="一般二叉树"></a>一般二叉树</h2><p>对于深度为n的一棵二叉树，节点个数在n至2^n-1之间。<br>同理，对于节点个数为n的二叉树，深度在log(n+1)至n之间。</p><blockquote><ol><li>若规定根结点的层数为1，则一棵非空二叉树的<strong>第i层上最多有2^(i-1)</strong> 个结点.</li><li>若规定根结点的层数为1，则<strong>深度为h的二叉树的最大结点数是2^h-1</strong>.</li><li>对任何一棵二叉树, <strong>如果度为0其叶结点个数为 n_0, 度为2的分支结点个数为 n_2,则有n_0＝n_2＋1</strong></li><li>若规定根结点的层数为1，具有<strong>n个结点的满二叉树的深度</strong>，<strong>h&#x3D;log_2(n+1)</strong>.  (ps：log_2(n+1)是log以2为底，n+1为对数)</li><li>对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对于序号为i的结点有：<ol><li><strong>若i&gt;0，i位置结点的双亲序号：(i-1)&#x2F;2</strong>；i&#x3D;0，i为根结点编号，无双亲结点</li><li><strong>若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;&#x3D;n否则无左孩子</strong></li><li><strong>若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;&#x3D;n否则无右孩子</strong></li></ol></li></ol></blockquote>]]></content>
    
    
    <summary type="html">简要介绍二叉树的结构、性质</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://www.deltamaya.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://www.deltamaya.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://www.deltamaya.top/tags/C/"/>
    
    <category term="数据结构" scheme="http://www.deltamaya.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="http://www.deltamaya.top/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="http://www.deltamaya.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="http://www.deltamaya.top/2023/03/28/%E5%A0%86md/"/>
    <id>http://www.deltamaya.top/2023/03/28/%E5%A0%86md/</id>
    <published>2023-03-28T03:55:33.737Z</published>
    <updated>2023-03-28T04:06:50.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h1><p>堆又称<strong>优先队列</strong>，其本质上就是一颗<strong>完全二叉树</strong>，并使用数组的方法实现。堆又分为<strong>大根堆与小根堆</strong>，大根堆就是对于每个节点，它的值比左孩子的值和右孩子的值都大，小根堆即对于每个节点，它的值比左孩子和右孩子的值都小。</p><p>以大根堆为例，堆的结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;heap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> sz;</span><br><span class="line"><span class="built_in">Heap</span>():<span class="built_in">heap</span>(),<span class="built_in">sz</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="堆的性质（大根堆）"><a href="#堆的性质（大根堆）" class="headerlink" title="堆的性质（大根堆）"></a>堆的性质（大根堆）</h1><p>大根堆的性质就是对于每个节点，它的值比左孩子的值和右孩子的值都大。<br>为了维护这个性质，在每次插入和删除元素之后我们都要调整堆的结构。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入调整方式如图所示：<br><img src="/../img/heapPush.png" alt="堆插入"></p><p><br>当子节点还存在父节点时，若子节点大于父节点，则调换两者位置，然后更新父节点与子节点的位置，知道条件不成立或者子节点没有父节点。<br>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">heap.<span class="built_in">push_back</span> (x);</span><br><span class="line"><span class="comment">//每个节点的父节点都可以由(n-1)/2求得</span></span><br><span class="line"><span class="comment">//向上调整</span></span><br><span class="line"><span class="type">int</span> child=sz,father=(sz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(child&amp;&amp;heap[child]&gt;heap[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[child],heap[father]);</span><br><span class="line">child=father;</span><br><span class="line">father=(father<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">++sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除时，我们需要注意需要把最后一个元素与堆顶元素进行交换，然后将堆顶元素向下调整。<br><img src="/../img/heapPop.png" alt="堆弹出"><br>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret=heap[<span class="number">0</span>];</span><br><span class="line">--sz;</span><br><span class="line"><span class="built_in">swap</span>(heap[<span class="number">0</span>],heap[sz]);</span><br><span class="line"><span class="comment">//向下调整</span></span><br><span class="line"><span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="comment">//选出子节点的最大值</span></span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;heap[child+<span class="number">1</span>]&gt;heap[child]) &#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(heap[child]&gt;heap[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[child],heap[father]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">father=child;</span><br><span class="line">child=child*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><p>堆的性质可以帮助我们选出一组数据中<strong>权最大的那个元素</strong>（在这个例子中是数值最大的元素），因此我们可以使用其性质进行排序。</p><h2 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line"><span class="comment">//向上调整建堆</span></span><br><span class="line"><span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;++i)&#123;</span><br><span class="line"><span class="type">int</span> child=i,father=(child<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(child&amp;&amp;v[child]&gt;v[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">child=father;</span><br><span class="line">father=(father<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始排序</span></span><br><span class="line"><span class="keyword">while</span>(--sz)&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line"><span class="type">int</span> child=<span class="number">1</span>,father=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">father=child;</span><br><span class="line">child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>最容易想到的方法是对一个数组向上调整建堆，就像逐个插入一样，但是这样做的时间复杂度是<strong>O(nlogn)<strong>，其实我们有更快的方法，那就是</strong>向下调整建堆</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line"><span class="comment">//向下调整建堆</span></span><br><span class="line"><span class="type">int</span> sz=v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> tmp=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;tmp&gt;<span class="number">0</span>;--tmp)&#123;</span><br><span class="line"><span class="type">int</span> father=tmp,child=father*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">father=child;</span><br><span class="line">child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始排序</span></span><br><span class="line"><span class="keyword">while</span>(--sz)&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[<span class="number">0</span>],v[sz]);</span><br><span class="line"><span class="type">int</span> child=<span class="number">1</span>,father=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;v[child+<span class="number">1</span>]&gt;v[child])&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[child]&gt;v[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(v[child],v[father]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">father=child;</span><br><span class="line">child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>我们可以从数学角度证明，向下调整建堆的时间复杂度是O(n)，优于向上建堆。<br>数学证明如下：<br><img src="/../img/upAdjustMath.png" alt="向上调整建堆"></p><p><img src="/../img/downAdjustMath.png" alt="向下调整建堆"></p><p>此外，我们要注意，建堆并不是排序的过程，因此升序需要建大堆，降序要建小堆</p><h2 id="TopK："><a href="#TopK：" class="headerlink" title="TopK："></a>TopK：</h2><p>由于二叉堆的性质，我们可以不断的选出一组数据中权最大数，这就是TopK问题：<br>例如：<br>我们可以通过小根堆选出100000个数中最大10个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topK</span><span class="params">(ifstream&amp; fin,<span class="type">const</span> <span class="type">int</span>&amp; K)</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(K);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;++i)&#123;</span><br><span class="line">fin&gt;&gt;ret[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向下调整建堆(小根堆）</span></span><br><span class="line"><span class="type">int</span> sz=K;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> tmp=(sz<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;tmp&gt;<span class="number">0</span>;--tmp)&#123;</span><br><span class="line"><span class="type">int</span> father=tmp,child=father*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(child&lt;sz)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;ret[child+<span class="number">1</span>]&lt;ret[child])&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ret[child]&lt;ret[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(ret[child],ret[father]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">father=child;</span><br><span class="line">child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">while</span>(fin&gt;&gt;tmp)&#123;</span><br><span class="line"><span class="comment">//比堆顶大就入堆</span></span><br><span class="line"><span class="keyword">if</span>(tmp&gt;ret[<span class="number">0</span>])&#123;</span><br><span class="line">ret[<span class="number">0</span>]=tmp;</span><br><span class="line"><span class="type">int</span> father=<span class="number">0</span>,child=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//向下调整</span></span><br><span class="line"><span class="keyword">while</span>(child&lt;K)&#123;</span><br><span class="line"><span class="keyword">if</span>(child+<span class="number">1</span>&lt;sz&amp;&amp;ret[child+<span class="number">1</span>]&lt;ret[child])&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ret[child]&lt;ret[father])&#123;</span><br><span class="line"><span class="built_in">swap</span>(ret[child],ret[father]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">father=child;</span><br><span class="line">child=(child*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，与堆排序不同，<strong>topK要把目标权最小的元素放在堆顶</strong>，例如这里要选出最大的，就要把目前所遇到的最小的元素放在堆顶，使用小根堆</p>]]></content>
    
    
    <summary type="html">简要介绍堆的结构、性质与简单应用</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://www.deltamaya.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://www.deltamaya.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C++" scheme="http://www.deltamaya.top/tags/C/"/>
    
    <category term="数据结构" scheme="http://www.deltamaya.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="堆" scheme="http://www.deltamaya.top/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>IEEE标准的浮点数表示</title>
    <link href="http://www.deltamaya.top/2023/03/27/IEEE%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/"/>
    <id>http://www.deltamaya.top/2023/03/27/IEEE%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</id>
    <published>2023-03-27T09:24:02.443Z</published>
    <updated>2023-03-27T14:00:16.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构介绍"><a href="#结构介绍" class="headerlink" title="结构介绍"></a>结构介绍</h1><p>因为计算机中只能离散的保存数据，那么数据的最小位就决定了数据精度。<br>例如： </p><ul><li>表示整数(int)类型时，最小位是2^0&#x3D;1,因此精度就是1，int类型无法保存任何模1不等于0的数。</li></ul><p>而小数却不存在最小位（无穷小），因此IEEE协会制定了一种用于表示浮点数的存储方式。<br>已知：</p><blockquote><p>任何十进制的数都可以表示为n&#x3D;(-1)^s*M*10^E的形式</p></blockquote><p>其中s是符号位,n为负数时s为0，n为正数时s为1，m是一个尾数，位于1~10之间，e是幂次。例如：12345&#x3D;(-1)^0*1.2345*10^4.</p><p>同理：</p><blockquote><p>任何二进制数都可以表示为n&#x3D;(-1)^s*M*2^E的形式</p></blockquote><p>符号含义：</p><ul><li>s:符号(sign)</li><li>M:尾数(significand)</li><li>E:阶码(exponet)</li><li>同时，我们用m代表M中存储的值，e表示E中存储的值。</li></ul><p>所以，如果我们要存储2进制浮点数，只需要存储s、M、E的值即可。<br>由上述公式可知，m位于1~2之间，因此其最高位总是为1，我们将其省略。<br><br>此外，为了存储e为负数的浮点数，对于E有k位的浮点数，还存在一个<strong>偏置 Bias &#x3D; 2^k-1</strong>,E最终的值要加上偏置后再进行存储。至于为什么不使用负号来表示E，我们之后再展示。<br><br>以32位float为例：</p><p><img src="/../img/floatStructure.png" alt="float的具体结构"><br>这样，我们就有了表示浮点数的方法。</p><h1 id="值的表示"><a href="#值的表示" class="headerlink" title="值的表示"></a>值的表示</h1><p>这种表示浮点数的方式有三种情况：</p><ul><li><strong>规格化的值</strong><br>E中的位不全为0，也不全为1。<br>此时n可以由(-1)^s*(1+m)*2^(e-Bias)计算得出。</li><li><strong>非规格化的值</strong><br>因为我们假定M始终大于1，所以我们无法表示0.<br>而当<strong>阶码E全为0</strong>时，浮点数表示非规格化的值，它为我们提供了表示0的方法，此时<strong>e&#x3D;1-Bias</strong>。<br>例如：<br>0 00000000 0000000… 表示+0.0<br>1 00000000 0000000… 表示-0.0<br>根据IEEE的浮点格式，+0与-0在某些方面是不同的，而在其他方面是相同的。<br>非规格化数的另一种功能是表示非常接近于0的值。</li><li><strong>特殊值</strong><br>最后一类数值是当<strong>阶码E全为1</strong>是出现的。<br>当小数域全为0时，表示<strong>无穷</strong><br>当小数域不为0时，表示<strong>NaN</strong>（不是一个数）<br>例如当两个非常大的数相乘，或者除以0时，会产生无穷。<br>当一些运算不能是实数或者无穷时，返回NaN</li></ul>]]></content>
    
    
    <summary type="html">简要介绍IEEE标准下的浮点数结构与表示</summary>
    
    
    
    <category term="CSAPP" scheme="http://www.deltamaya.top/categories/CSAPP/"/>
    
    
    <category term="信息的表示与处理" scheme="http://www.deltamaya.top/tags/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/"/>
    
    <category term="浮点数" scheme="http://www.deltamaya.top/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
    <category term="浮点" scheme="http://www.deltamaya.top/tags/%E6%B5%AE%E7%82%B9/"/>
    
  </entry>
  
</feed>
